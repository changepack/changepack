# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mock_redis` gem.
# Please instead update this file by running `bin/tapioca gem mock_redis`.

# Defines the gem version.
#
# source://mock_redis//lib/mock_redis/assertions.rb#1
class MockRedis
  include ::MockRedis::UndefRedisMethods

  # @return [MockRedis] a new instance of MockRedis
  #
  # source://mock_redis//lib/mock_redis.rb#34
  def initialize(*args); end

  # source://mock_redis//lib/mock_redis.rb#53
  def call(command, &_block); end

  # source://mock_redis//lib/mock_redis.rb#77
  def client; end

  # source://mock_redis//lib/mock_redis.rb#81
  def connect; end

  # source://mock_redis//lib/mock_redis.rb#65
  def db; end

  # source://mock_redis//lib/mock_redis.rb#57
  def host; end

  # source://mock_redis//lib/mock_redis.rb#48
  def id; end

  # source://mock_redis//lib/mock_redis.rb#48
  def location; end

  # source://mock_redis//lib/mock_redis.rb#69
  def logger; end

  # source://mock_redis//lib/mock_redis.rb#93
  def method_missing(method, *args, **_arg2, &block); end

  # Returns the value of attribute options.
  #
  # source://mock_redis//lib/mock_redis.rb#16
  def options; end

  # source://mock_redis//lib/mock_redis.rb#61
  def port; end

  # source://mock_redis//lib/mock_redis.rb#85
  def reconnect; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis.rb#89
  def respond_to?(method, include_private = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis.rb#73
  def time_at(timestamp); end

  protected

  # source://mock_redis//lib/mock_redis.rb#106
  def _parse_options(options); end

  # source://mock_redis//lib/mock_redis.rb#150
  def logging(commands); end

  private

  # source://mock_redis//lib/mock_redis.rb#99
  def initialize_copy(source); end

  class << self
    # source://mock_redis//lib/mock_redis.rb#30
    def connect(*args); end
  end
end

# source://mock_redis//lib/mock_redis/assertions.rb#2
module MockRedis::Assertions
  private

  # source://mock_redis//lib/mock_redis/assertions.rb#5
  def assert_has_args(args, command); end
end

# source://mock_redis//lib/mock_redis/connection_method.rb#2
module MockRedis::ConnectionMethod
  # source://mock_redis//lib/mock_redis/connection_method.rb#3
  def connection; end
end

# source://mock_redis//lib/mock_redis.rb#18
MockRedis::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/database.rb#17
class MockRedis::Database
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods
  include ::MockRedis::HashMethods
  include ::MockRedis::ListMethods
  include ::MockRedis::SetMethods
  include ::MockRedis::StringMethods
  include ::MockRedis::ZsetMethods
  include ::MockRedis::SortMethod
  include ::MockRedis::InfoMethod
  include ::MockRedis::GeospatialMethods
  include ::MockRedis::StreamMethods
  include ::MockRedis::ConnectionMethod

  # @return [Database] a new instance of Database
  #
  # source://mock_redis//lib/mock_redis/database.rb#32
  def initialize(base, *_args); end

  # Redis commands go below this line and above 'private'
  #
  # source://mock_redis//lib/mock_redis/database.rb#46
  def auth(_); end

  # source://mock_redis//lib/mock_redis/database.rb#50
  def bgrewriteaof; end

  # source://mock_redis//lib/mock_redis/database.rb#54
  def bgsave; end

  # source://mock_redis//lib/mock_redis/database.rb#58
  def close; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#64
  def connected?; end

  # Returns the value of attribute data.
  #
  # source://mock_redis//lib/mock_redis/database.rb#30
  def data; end

  # source://mock_redis//lib/mock_redis/database.rb#68
  def dbsize; end

  # source://mock_redis//lib/mock_redis/database.rb#72
  def del(*keys); end

  # source://mock_redis//lib/mock_redis/database.rb#58
  def disconnect; end

  # source://mock_redis//lib/mock_redis/database.rb#58
  def disconnect!; end

  # source://mock_redis//lib/mock_redis/database.rb#134
  def dump(key); end

  # source://mock_redis//lib/mock_redis/database.rb#84
  def echo(msg); end

  # source://mock_redis//lib/mock_redis/database.rb#279
  def eval(*args); end

  # source://mock_redis//lib/mock_redis/database.rb#277
  def evalsha(*args); end

  # source://mock_redis//lib/mock_redis/database.rb#120
  def exists(*keys); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#124
  def exists?(*keys); end

  # source://mock_redis//lib/mock_redis/database.rb#88
  def expire(key, seconds); end

  # This method isn't private, but it also isn't a Redis command, so
  # it doesn't belong up above with all the Redis commands.
  #
  # source://mock_redis//lib/mock_redis/database.rb#367
  def expire_keys; end

  # Returns the value of attribute expire_times.
  #
  # source://mock_redis//lib/mock_redis/database.rb#30
  def expire_times; end

  # source://mock_redis//lib/mock_redis/database.rb#102
  def expireat(key, timestamp); end

  # source://mock_redis//lib/mock_redis/database.rb#129
  def flushdb; end

  # source://mock_redis//lib/mock_redis/database.rb#150
  def keys(format = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#168
  def lastsave; end

  # source://mock_redis//lib/mock_redis/database.rb#250
  def now; end

  # source://mock_redis//lib/mock_redis/database.rb#172
  def persist(key); end

  # source://mock_redis//lib/mock_redis/database.rb#94
  def pexpire(key, ms); end

  # source://mock_redis//lib/mock_redis/database.rb#108
  def pexpireat(key, timestamp_ms); end

  # source://mock_redis//lib/mock_redis/database.rb#181
  def ping(response = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#237
  def pttl(key); end

  # source://mock_redis//lib/mock_redis/database.rb#185
  def quit; end

  # source://mock_redis//lib/mock_redis/database.rb#189
  def randomkey; end

  # source://mock_redis//lib/mock_redis/database.rb#193
  def rename(key, newkey); end

  # source://mock_redis//lib/mock_redis/database.rb#209
  def renamenx(key, newkey); end

  # source://mock_redis//lib/mock_redis/database.rb#139
  def restore(key, ttl, value, replace: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#222
  def save; end

  # source://mock_redis//lib/mock_redis/database.rb#154
  def scan(cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#158
  def scan_each(opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/database.rb#275
  def script(subcommand, *args); end

  # source://mock_redis//lib/mock_redis/database.rb#250
  def time; end

  # source://mock_redis//lib/mock_redis/database.rb#226
  def ttl(key); end

  # source://mock_redis//lib/mock_redis/database.rb#257
  def type(key); end

  # source://mock_redis//lib/mock_redis/database.rb#72
  def unlink(*keys); end

  private

  # source://mock_redis//lib/mock_redis/database.rb#283
  def assert_valid_integer(integer); end

  # source://mock_redis//lib/mock_redis/database.rb#290
  def assert_valid_timeout(timeout); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#299
  def can_incr?(value); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#303
  def can_incr_float?(value); end

  # source://mock_redis//lib/mock_redis/database.rb#320
  def expiration(key); end

  # source://mock_redis//lib/mock_redis/database.rb#307
  def extract_timeout(arglist); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#324
  def has_expiration?(key); end

  # source://mock_redis//lib/mock_redis/database.rb#38
  def initialize_copy(_source); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#332
  def looks_like_float?(str); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#328
  def looks_like_integer?(str); end

  # source://mock_redis//lib/mock_redis/database.rb#336
  def redis_pattern_to_ruby_regex(pattern); end

  # source://mock_redis//lib/mock_redis/database.rb#345
  def remove_expiration(key); end

  # source://mock_redis//lib/mock_redis/database.rb#351
  def set_expiration(key, time); end

  # source://mock_redis//lib/mock_redis/database.rb#358
  def zero_pad(string, desired_length); end
end

# source://mock_redis//lib/mock_redis/expire_wrapper.rb#4
class MockRedis::ExpireWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [ExpireWrapper] a new instance of ExpireWrapper
  #
  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#11
  def initialize(db); end

  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#15
  def method_missing(method, *args, **_arg2, &block); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#7
  def respond_to?(method, include_private = T.unsafe(nil)); end

  private

  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#20
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/future.rb#4
class MockRedis::Future
  # @return [Future] a new instance of Future
  #
  # source://mock_redis//lib/mock_redis/future.rb#7
  def initialize(command, block = T.unsafe(nil)); end

  # Returns the value of attribute block.
  #
  # source://mock_redis//lib/mock_redis/future.rb#5
  def block; end

  # Returns the value of attribute command.
  #
  # source://mock_redis//lib/mock_redis/future.rb#5
  def command; end

  # source://mock_redis//lib/mock_redis/future.rb#18
  def store_result(result); end

  # @raise [FutureNotReady]
  #
  # source://mock_redis//lib/mock_redis/future.rb#13
  def value; end
end

# source://mock_redis//lib/mock_redis/future.rb#2
class MockRedis::FutureNotReady < ::RuntimeError; end

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#2
module MockRedis::GeospatialMethods
  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#15
  def geoadd(key, *args, **_arg2); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#26
  def geodist(key, member1, member2, unit = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#44
  def geohash(key, members); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#66
  def geopos(key, members); end

  private

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#155
  def calculate_approximate_area(hash, lng_range, lat_range); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#232
  def deg_rad(ang); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#174
  def deinterleave(bits); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#203
  def format_decoded_coord(coord); end

  # Decodes ZSET score to coordinates pair
  #
  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#146
  def geohash_decode(hash, lng_range = T.unsafe(nil), lat_range = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#219
  def geohash_distance(lng1d, lat1d, lng2d, lat2d); end

  # Returns ZSET score for passed coordinates
  #
  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#110
  def geohash_encode(lng, lat, lng_range = T.unsafe(nil), lat_range = T.unsafe(nil), step = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#122
  def interleave(x, y); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#93
  def parse_point(point); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#80
  def parse_points(args); end

  # @raise [Redis::CommandError]
  #
  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#211
  def parse_unit(unit); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#236
  def rad_deg(ang); end
end

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#12
MockRedis::GeospatialMethods::D_R = T.let(T.unsafe(nil), Float)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#13
MockRedis::GeospatialMethods::EARTH_RADIUS_IN_METERS = T.let(T.unsafe(nil), Float)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#4
MockRedis::GeospatialMethods::LAT_RANGE = T.let(T.unsafe(nil), Range)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#3
MockRedis::GeospatialMethods::LNG_RANGE = T.let(T.unsafe(nil), Range)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#5
MockRedis::GeospatialMethods::STEP = T.let(T.unsafe(nil), Integer)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#6
MockRedis::GeospatialMethods::UNITS = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/hash_methods.rb#5
module MockRedis::HashMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/hash_methods.rb#9
  def hdel(key, *fields); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#23
  def hexists(key, field); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#27
  def hget(key, field); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#31
  def hgetall(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#35
  def hincrby(key, field, increment); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#51
  def hincrbyfloat(key, field, increment); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#69
  def hkeys(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#73
  def hlen(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#77
  def hmget(key, *fields); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#93
  def hmset(key, *kvpairs); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#123
  def hscan(key, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#128
  def hscan_each(key, opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#138
  def hset(key, *args); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#153
  def hsetnx(key, field, value); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#162
  def hvals(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#84
  def mapped_hmget(key, *fields); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#113
  def mapped_hmset(key, hash); end

  private

  # source://mock_redis//lib/mock_redis/hash_methods.rb#176
  def assert_hashy(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/hash_methods.rb#172
  def hashy?(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#168
  def with_hash_at(key, &blk); end
end

# source://mock_redis//lib/mock_redis/indifferent_hash.rb#2
class MockRedis::IndifferentHash < ::Hash
  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/indifferent_hash.rb#3
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/indifferent_hash.rb#7
  def key?(key); end
end

# source://mock_redis//lib/mock_redis/info_method.rb#2
module MockRedis::InfoMethod
  # source://mock_redis//lib/mock_redis/info_method.rb#144
  def info(section = T.unsafe(nil)); end
end

# source://mock_redis//lib/mock_redis/info_method.rb#139
MockRedis::InfoMethod::ALL_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#20
MockRedis::InfoMethod::CLIENTS_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#107
MockRedis::InfoMethod::COMMAND_STATS_COMBINED_INFO = T.let(T.unsafe(nil), Hash)

# The Ruby Redis client returns commandstats differently when it's called as
# "INFO commandstats".
#
# source://mock_redis//lib/mock_redis/info_method.rb#87
MockRedis::InfoMethod::COMMAND_STATS_SOLO_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#73
MockRedis::InfoMethod::CPU_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#128
MockRedis::InfoMethod::DEFAULT_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#80
MockRedis::InfoMethod::KEYSPACE_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#27
MockRedis::InfoMethod::MEMORY_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#38
MockRedis::InfoMethod::PERSISTENCE_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#68
MockRedis::InfoMethod::REPLICATION_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#3
MockRedis::InfoMethod::SERVER_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#54
MockRedis::InfoMethod::STATS_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/list_methods.rb#5
module MockRedis::ListMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/list_methods.rb#9
  def blpop(*args); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#22
  def brpop(*args); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#35
  def brpoplpush(source, destination, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#49
  def lindex(key, index); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#53
  def linsert(key, position, pivot, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#77
  def llen(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#81
  def lpop(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#85
  def lpush(key, values); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#92
  def lpushx(key, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#102
  def lrange(key, start, stop); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#107
  def lrem(key, count, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#131
  def lset(key, index, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#147
  def ltrim(key, start, stop); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#154
  def rpop(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#158
  def rpoplpush(source, destination); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#164
  def rpush(key, values); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#171
  def rpushx(key, value); end

  private

  # source://mock_redis//lib/mock_redis/list_methods.rb#195
  def assert_listy(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#203
  def first_nonempty_list(keys); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/list_methods.rb#183
  def list_at?(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/list_methods.rb#191
  def listy?(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#187
  def with_list_at(key, &blk); end
end

# source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#4
class MockRedis::MultiDbWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [MultiDbWrapper] a new instance of MultiDbWrapper
  #
  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#7
  def initialize(db); end

  # Redis commands
  #
  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#33
  def flushall; end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#20
  def method_missing(method, *args, **_arg2, &block); end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#38
  def move(key, db_index); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#16
  def respond_to?(method, include_private = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#72
  def select(db_index); end

  private

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#79
  def current_db; end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#83
  def db(index); end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#24
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#2
class MockRedis::PipelinedWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [PipelinedWrapper] a new instance of PipelinedWrapper
  #
  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#9
  def initialize(db); end

  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#21
  def method_missing(method, *args, **_arg2, &block); end

  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#31
  def pipelined(_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#5
  def respond_to?(method, include_private = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#67
  def in_pipeline?; end

  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#15
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/set_methods.rb#5
module MockRedis::SetMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/set_methods.rb#9
  def sadd(key, members); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#30
  def scard(key); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#34
  def sdiff(*keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#39
  def sdiffstore(destination, *keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#47
  def sinter(*keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#55
  def sinterstore(destination, *keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#63
  def sismember(key, member); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#67
  def smembers(key); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#71
  def smove(src, dest, member); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#84
  def spop(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#103
  def srandmember(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#116
  def srem(key, members); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#129
  def sscan(key, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#133
  def sscan_each(key, opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#143
  def sunion(*keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#148
  def sunionstore(destination, *keys); end

  private

  # source://mock_redis//lib/mock_redis/set_methods.rb#179
  def assert_sety(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/set_methods.rb#175
  def sety?(key); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#158
  def with_set_at(key, &blk); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#162
  def with_sets_at(*keys, &blk); end
end

# source://mock_redis//lib/mock_redis/sort_method.rb#4
module MockRedis::SortMethod
  include ::MockRedis::Assertions

  # source://mock_redis//lib/mock_redis/sort_method.rb#7
  def sort(key, options = T.unsafe(nil)); end

  private

  # source://mock_redis//lib/mock_redis/sort_method.rb#71
  def lookup_from_pattern(pattern, element); end

  # source://mock_redis//lib/mock_redis/sort_method.rb#33
  def project(enumerable, by, get_patterns); end

  # source://mock_redis//lib/mock_redis/sort_method.rb#64
  def slice(sorted, limit); end

  # source://mock_redis//lib/mock_redis/sort_method.rb#50
  def sort_by(projected, direction); end
end

# source://mock_redis//lib/mock_redis/sort_method.rb#30
MockRedis::SortMethod::ASCENDING_SORT = T.let(T.unsafe(nil), Proc)

# source://mock_redis//lib/mock_redis/sort_method.rb#31
MockRedis::SortMethod::DESCENDING_SORT = T.let(T.unsafe(nil), Proc)

# source://mock_redis//lib/mock_redis/stream/id.rb#2
class MockRedis::Stream
  include ::Enumerable
  extend ::Forwardable

  # @return [Stream] a new instance of Stream
  #
  # source://mock_redis//lib/mock_redis/stream.rb#15
  def initialize; end

  # source://mock_redis//lib/mock_redis/stream.rb#24
  def add(id, values); end

  # source://mock_redis//lib/mock_redis/stream.rb#74
  def each; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def empty?(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/stream.rb#20
  def last_id; end

  # Returns the value of attribute members.
  #
  # source://mock_redis//lib/mock_redis/stream.rb#11
  def members; end

  # Sets the attribute members
  #
  # @param value the value to set the attribute members to.
  #
  # source://mock_redis//lib/mock_redis/stream.rb#11
  def members=(_arg0); end

  # source://mock_redis//lib/mock_redis/stream.rb#48
  def range(start, finish, reversed, *opts_in); end

  # source://mock_redis//lib/mock_redis/stream.rb#66
  def read(id, *opts_in); end

  # source://mock_redis//lib/mock_redis/stream.rb#34
  def trim(count); end

  private

  # @raise [Redis::CommandError]
  #
  # source://mock_redis//lib/mock_redis/stream.rb#80
  def options(opts_in, permitted); end
end

# source://mock_redis//lib/mock_redis/stream/id.rb#3
class MockRedis::Stream::Id
  include ::Comparable

  # @return [Id] a new instance of Id
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#8
  def initialize(id, min: T.unsafe(nil), sequence: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream/id.rb#51
  def <=>(other); end

  # Returns the value of attribute exclusive.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def exclusive; end

  # Sets the attribute exclusive
  #
  # @param value the value to set the attribute exclusive to.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def exclusive=(_arg0); end

  # Returns the value of attribute sequence.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def sequence; end

  # Sets the attribute sequence
  #
  # @param value the value to set the attribute sequence to.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def sequence=(_arg0); end

  # Returns the value of attribute timestamp.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def timestamp; end

  # Sets the attribute timestamp
  #
  # @param value the value to set the attribute timestamp to.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def timestamp=(_arg0); end

  # source://mock_redis//lib/mock_redis/stream/id.rb#47
  def to_s; end
end

# source://mock_redis//lib/mock_redis/stream_methods.rb#28
module MockRedis::StreamMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/stream_methods.rb#32
  def xadd(key, entry, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#47
  def xlen(key); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#53
  def xrange(key, first = T.unsafe(nil), last = T.unsafe(nil), count: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#69
  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#61
  def xrevrange(key, last = T.unsafe(nil), first = T.unsafe(nil), count: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#41
  def xtrim(key, count); end

  private

  # source://mock_redis//lib/mock_redis/stream_methods.rb#95
  def assert_streamy(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/stream_methods.rb#91
  def streamy?(key); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#87
  def with_stream_at(key, &blk); end
end

# source://mock_redis//lib/mock_redis/string_methods.rb#4
module MockRedis::StringMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/string_methods.rb#8
  def append(key, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#294
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#15
  def bitfield(*args); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#79
  def decr(key); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#83
  def decrby(key, n); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#87
  def get(key); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#93
  def getbit(key, offset); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#110
  def getrange(key, start, stop); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#115
  def getset(key, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#121
  def incr(key); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#125
  def incrby(key, n); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#141
  def incrbyfloat(key, n); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#169
  def mapped_mget(*keys); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#188
  def mapped_mset(hash); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#203
  def mapped_msetnx(hash); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#157
  def mget(*keys, &blk); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#173
  def mset(*kvpairs); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#192
  def msetnx(*kvpairs); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#331
  def psetex(key, milliseconds, value); end

  # Parameer list required to ensure the ArgumentError is returned correctly
  #
  # source://mock_redis//lib/mock_redis/string_methods.rb#209
  def set(key, value, ex: T.unsafe(nil), px: T.unsafe(nil), nx: T.unsafe(nil), xx: T.unsafe(nil), keepttl: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#247
  def setbit(key, offset, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#321
  def setex(key, seconds, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#341
  def setnx(key, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#350
  def setrange(key, offset, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#360
  def strlen(key); end

  private

  # source://mock_redis//lib/mock_redis/string_methods.rb#371
  def assert_stringy(key, message = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#391
  def incr_bitfield(val, incrby, is_signed, type_size, overflow_method); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#378
  def set_bitfield(key, value, is_signed, type_size, offset); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/string_methods.rb#367
  def stringy?(key); end
end

# source://mock_redis//lib/mock_redis/transaction_wrapper.rb#4
class MockRedis::TransactionWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [TransactionWrapper] a new instance of TransactionWrapper
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#11
  def initialize(db); end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#41
  def discard; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#51
  def exec; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#73
  def in_multi?; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#18
  def method_missing(method, *args, **_arg2, &block); end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#85
  def multi; end

  # @yield [_self]
  # @yieldparam _self [MockRedis::TransactionWrapper] the object that the method was called on
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#103
  def pipelined; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#81
  def pop_multi; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#77
  def push_multi; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#7
  def respond_to?(method, include_private = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#107
  def unwatch; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#111
  def watch(*_); end

  private

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#34
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/undef_redis_methods.rb#2
module MockRedis::UndefRedisMethods
  class << self
    # @private
    #
    # source://mock_redis//lib/mock_redis/undef_redis_methods.rb#3
    def included(klass); end
  end
end

# source://mock_redis//lib/mock_redis/utility_methods.rb#2
module MockRedis::UtilityMethods
  private

  # source://mock_redis//lib/mock_redis/utility_methods.rb#20
  def clean_up_empties_at(key); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#26
  def common_scan(values, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#70
  def left_pad(str, size); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/utility_methods.rb#16
  def primitive?(value); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#59
  def twos_complement_decode(array); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#45
  def twos_complement_encode(n, size); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#5
  def with_thing_at(key, assertion, empty_thing_generator); end
end

# source://mock_redis//lib/mock_redis/exceptions.rb#2
class MockRedis::WouldBlock < ::StandardError; end

# source://mock_redis//lib/mock_redis/zset.rb#5
class MockRedis::Zset
  include ::Enumerable
  extend ::Forwardable

  # @return [Zset] a new instance of Zset
  #
  # source://mock_redis//lib/mock_redis/zset.rb#13
  def initialize; end

  # source://mock_redis//lib/mock_redis/zset.rb#24
  def add(score, member); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset.rb#30
  def delete?(member); end

  # source://mock_redis//lib/mock_redis/zset.rb#35
  def each; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def empty?(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/zset.rb#39
  def in_range(min, max); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def include?(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/zset.rb#69
  def intersection(other); end

  # Returns the value of attribute members.
  #
  # source://mock_redis//lib/mock_redis/zset.rb#9
  def members; end

  # source://mock_redis//lib/mock_redis/zset.rb#80
  def score(member); end

  # Returns the value of attribute scores.
  #
  # source://mock_redis//lib/mock_redis/zset.rb#9
  def scores; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def size(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/zset.rb#84
  def sorted; end

  # source://mock_redis//lib/mock_redis/zset.rb#90
  def sorted_members; end

  # source://mock_redis//lib/mock_redis/zset.rb#94
  def union(other); end

  private

  # source://mock_redis//lib/mock_redis/zset.rb#18
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/zset_methods.rb#6
module MockRedis::ZsetMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/zset_methods.rb#10
  def zadd(key, *args); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#89
  def zcard(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#93
  def zcount(key, min, max); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#101
  def zincrby(key, increment, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#112
  def zinterstore(destination, keys, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#167
  def zpopmax(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#158
  def zpopmin(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#119
  def zrange(key, start, stop, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#127
  def zrangebyscore(key, min, max, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#136
  def zrank(key, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#140
  def zrem(key, *args); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#182
  def zremrangebyrank(key, start, stop); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#188
  def zremrangebyscore(key, min, max); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#176
  def zrevrange(key, start, stop, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#196
  def zrevrangebyscore(key, max, min, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#210
  def zrevrank(key, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#214
  def zscan(key, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#219
  def zscan_each(key, opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#229
  def zscore(key, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#236
  def zunionstore(destination, keys, options = T.unsafe(nil)); end

  private

  # source://mock_redis//lib/mock_redis/zset_methods.rb#245
  def apply_limit(collection, limit); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#341
  def assert_coercible_zsety(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#362
  def assert_range_args(min, max); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#353
  def assert_scorey(value, message = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#334
  def assert_zsety(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#296
  def coerce_to_zset(set); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset_methods.rb#330
  def coercible_zsety?(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#268
  def combine_weighted_zsets(keys, options, how); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset_methods.rb#348
  def looks_like_float?(x); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#258
  def to_response(score_member_pairs, options); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#304
  def with_zset_at(key, coercible: T.unsafe(nil), &blk); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#314
  def with_zsets_at(*keys, coercible: T.unsafe(nil), &blk); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#59
  def zadd_multiple_members(key, args, zadd_options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#28
  def zadd_one_member(key, score, member, zadd_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset_methods.rb#326
  def zsety?(key); end
end
