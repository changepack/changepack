# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ruby_event_store` gem.
# Please instead update this file by running `bin/tapioca gem ruby_event_store`.

# source://ruby_event_store//lib/ruby_event_store/dispatcher.rb#3
module RubyEventStore; end

# source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#4
class RubyEventStore::BatchEnumerator
  # @return [BatchEnumerator] a new instance of BatchEnumerator
  #
  # source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#5
  def initialize(batch_size, total_limit, reader); end

  # source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#11
  def each; end

  # source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#23
  def first; end

  # source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#27
  def to_a; end

  private

  # Returns the value of attribute batch_size.
  #
  # source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#33
  def batch_size; end

  # Returns the value of attribute reader.
  #
  # source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#33
  def reader; end

  # Returns the value of attribute total_limit.
  #
  # source://ruby_event_store//lib/ruby_event_store/batch_enumerator.rb#33
  def total_limit; end
end

# source://ruby_event_store//lib/ruby_event_store/broker.rb#4
class RubyEventStore::Broker
  # @return [Broker] a new instance of Broker
  #
  # source://ruby_event_store//lib/ruby_event_store/broker.rb#5
  def initialize(subscriptions:, dispatcher:); end

  # source://ruby_event_store//lib/ruby_event_store/broker.rb#20
  def add_global_subscription(subscriber); end

  # source://ruby_event_store//lib/ruby_event_store/broker.rb#15
  def add_subscription(subscriber, event_types); end

  # source://ruby_event_store//lib/ruby_event_store/broker.rb#30
  def add_thread_global_subscription(subscriber); end

  # source://ruby_event_store//lib/ruby_event_store/broker.rb#25
  def add_thread_subscription(subscriber, event_types); end

  # source://ruby_event_store//lib/ruby_event_store/broker.rb#10
  def call(event, record); end

  private

  # Returns the value of attribute dispatcher.
  #
  # source://ruby_event_store//lib/ruby_event_store/broker.rb#37
  def dispatcher; end

  # Returns the value of attribute subscriptions.
  #
  # source://ruby_event_store//lib/ruby_event_store/broker.rb#37
  def subscriptions; end

  # @raise [SubscriberNotExist]
  #
  # source://ruby_event_store//lib/ruby_event_store/broker.rb#39
  def verify_subscription(subscriber); end
end

# source://ruby_event_store//lib/ruby_event_store/client.rb#6
class RubyEventStore::Client
  # @return [Client] a new instance of Client
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#7
  def initialize(repository:, mapper: T.unsafe(nil), subscriptions: T.unsafe(nil), dispatcher: T.unsafe(nil), clock: T.unsafe(nil), correlation_id_generator: T.unsafe(nil)); end

  # Persists new event(s) without notifying any subscribed handlers
  #
  # @param events [Array<Event>, Event] event(s)
  # @param stream_name [String] name of the stream for persisting events.
  # @param expected_version [:any, :auto, :none, Integer] controls optimistic locking strategy. {http://railseventstore.org/docs/expected_version/ Read more}
  # @return [self]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#46
  def append(events, stream_name: T.unsafe(nil), expected_version: T.unsafe(nil)); end

  # Deletes a stream.
  # All events from the stream remain intact but they are no
  # longer linked to the stream.
  #
  # @param stream_name [String] name of the stream to be cleared.
  # @return [self]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#73
  def delete_stream(stream_name); end

  # Deserialize event which was serialized for async event handlers
  # {http://railseventstore.org/docs/subscribe/#async-handlers Read more}
  #
  # @return [Event] deserialized event
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#269
  def deserialize(serializer:, event_type:, event_id:, data:, metadata:, timestamp: T.unsafe(nil), valid_at: T.unsafe(nil)); end

  # Checks whether event is linked in given stream
  #
  # @param event_id [String]
  # @param stream_name [String]
  # @return [Boolean] true if event is linked to given stream, false otherwise
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#125
  def event_in_stream?(event_id, stream_name); end

  # Gets position of the event in global stream
  #
  # The position is always nonnegative.
  # Global position may have gaps, meaning, there may be event at
  # position 40, but no event at position 39.
  #
  # @param event_id [String]
  # @raise [EventNotFound]
  # @return [Integer] nonnegno ative integer position of event in global stream
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#116
  def global_position(event_id); end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#328
  def inspect; end

  # Links already persisted event(s) to a different stream.
  # Does not notify any subscribed handlers.
  #
  # @param event_ids [String, Array<String>] ids of events
  # @param stream_name [String] name of the stream for persisting events.
  # @param expected_version [:any, :auto, :none, Integer] controls optimistic locking strategy. {http://railseventstore.org/docs/expected_version/ Read more}
  # @return [self]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#62
  def link(event_ids, stream_name:, expected_version: T.unsafe(nil)); end

  # Read additional metadata which will be added for published events
  # {http://railseventstore.org/docs/request_metadata#passing-your-own-metadata-using-with_metadata-method Read more}
  #
  # @return [Hash]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#290
  def metadata; end

  # Overwrite existing event(s) with the same ID.
  #
  # Does not notify any subscribed handlers.
  # Does not enrich with additional current metadata.
  # Does not allow changing which streams these events are in.
  # {http://railseventstore.org/docs/migrating_messages Read more}
  #
  # @example Add data and metadata to existing events
  #
  #   events = event_store.read.limit(10).to_a
  #   events.each do |ev|
  #   ev.data[:tenant_id] = 1
  #   ev.metadata[:server_id] = "eu-west-2"
  #   end
  #   event_store.overwrite(events)
  # @example Change event type
  #
  #   events = event_store.read.limit(10).each.select{|ev| OldType === ev }.map do |ev|
  #   NewType.new(
  #   event_id: ev.event_id,
  #   data: ev.data,
  #   metadata: ev.metadata,
  #   )
  #   end
  #   event_store.overwrite(events)
  # @param events [Array<Event>, Event] event(s) to serialize and overwrite again
  # @return [self]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#323
  def overwrite(events_or_event); end

  # Gets position of the event in given stream
  #
  # The position is always nonnegative.
  # Returns nil if the event has no specific position in stream.
  # Raise error if event is not present in stream.
  #
  # @param event_id [String]
  # @param stream_name [String]
  # @raise [EventNotInStream]
  # @return [Integer] nonnegative integer position of event in stream
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#103
  def position_in_stream(event_id, stream_name); end

  # Persists events and notifies subscribed handlers about them
  #
  # @param events [Array<Event>, Event] event(s)
  # @param stream_name [String] name of the stream for persisting events.
  # @param expected_version [:any, :auto, :none, Integer] controls optimistic locking strategy. {http://railseventstore.org/docs/expected_version/ Read more}
  # @return [self]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#30
  def publish(events, stream_name: T.unsafe(nil), expected_version: T.unsafe(nil)); end

  # Starts building a query specification for reading events.
  # {http://railseventstore.org/docs/read/ More info.}
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#82
  def read; end

  # Gets list of streams where event is stored or linked
  #
  # @return [Array<Stream>] where event is stored or linked
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#89
  def streams_of(event_id); end

  # Subscribes a handler (subscriber) that will be invoked for published events of provided type.
  #
  # @overload subscribe
  # @overload subscribe
  # @raise [ArgumentError]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#142
  def subscribe(subscriber = T.unsafe(nil), to:, &proc); end

  # Subscribes a handler (subscriber) that will be invoked for all published events
  #
  # @overload subscribe_to_all_events
  # @overload subscribe_to_all_events
  # @raise [ArgumentError]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#158
  def subscribe_to_all_events(subscriber = T.unsafe(nil), &proc); end

  # Get list of handlers subscribed to an event
  #
  # @param to [Class, String] type of events to get list of sybscribed handlers
  # @return [Array<Object, Class>]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#167
  def subscribers_for(event_class); end

  # Set additional metadata for all events published within the provided block
  # {http://railseventstore.org/docs/request_metadata#passing-your-own-metadata-using-with_metadata-method Read more}
  #
  # @param metadata [Hash] metadata to set for events
  # @param block [Proc] block of code during which the metadata will be added
  # @return [Object] last value returned by the provided block
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#257
  def with_metadata(metadata, &block); end

  # Use for starting temporary subscriptions.
  # {http://railseventstore.org/docs/subscribe/#temporary-subscriptions Read more}
  #
  # @param block [Proc] block of code during which the temporary subscriptions will be active
  # @raise [ArgumentError]
  # @return [Within] builder object which collects temporary subscriptions
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#246
  def within(&block); end

  protected

  # Returns the value of attribute broker.
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#376
  def broker; end

  # Returns the value of attribute clock.
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#376
  def clock; end

  # Returns the value of attribute correlation_id_generator.
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#376
  def correlation_id_generator; end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#368
  def default_clock; end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#372
  def default_correlation_id_generator; end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#360
  def event_type_resolver; end

  # Returns the value of attribute mapper.
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#376
  def mapper; end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#364
  def metadata=(value); end

  # Returns the value of attribute repository.
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#376
  def repository; end

  # Returns the value of attribute subscriptions.
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#376
  def subscriptions; end

  private

  # source://ruby_event_store//lib/ruby_event_store/client.rb#354
  def append_records_to_stream(records, stream_name:, expected_version:); end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#347
  def enrich_event_metadata(event); end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#341
  def enrich_events_metadata(events); end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#337
  def transform(events); end
end

# source://ruby_event_store//lib/ruby_event_store/client.rb#332
RubyEventStore::Client::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Builder object for collecting temporary handlers (subscribers)
# which are active only during the invocation of the provided
# block of code.
#
# source://ruby_event_store//lib/ruby_event_store/client.rb#174
class RubyEventStore::Client::Within
  # @return [Within] a new instance of Within
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#175
  def initialize(block, broker); end

  # Invokes the block of code provided to {Client#within}
  # and then unsubscribes temporary handlers.
  # {http://railseventstore.org/docs/subscribe/#temporary-subscriptions Read more.}
  #
  # @return [Object] value returned by the invoked block of code
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#222
  def call; end

  # Subscribes temporary handlers that
  # will be called for published events of provided type.
  # The subscription is active only during the invocation
  # of the block of code provided to {Client#within}.
  # {http://railseventstore.org/docs/subscribe/#temporary-subscriptions Read more.}
  #
  # @overload subscribe
  # @overload subscribe
  # @raise [ArgumentError]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#211
  def subscribe(handler = T.unsafe(nil), to:, &handler2); end

  # Subscribes temporary handlers that
  # will be called for all published events.
  # The subscription is active only during the invocation
  # of the block of code provided to {Client#within}.
  # {http://railseventstore.org/docs/subscribe/#temporary-subscriptions Read more.}
  #
  # @param handlers [Object, Class] handlers passed as objects or classes
  # @param handler2 [Proc] handler passed as proc
  # @return [self]
  #
  # source://ruby_event_store//lib/ruby_event_store/client.rb#191
  def subscribe_to_all_events(*handlers, &handler2); end

  private

  # source://ruby_event_store//lib/ruby_event_store/client.rb#236
  def add_thread_global_subscribers; end

  # source://ruby_event_store//lib/ruby_event_store/client.rb#232
  def add_thread_subscribers; end
end

# source://ruby_event_store//lib/ruby_event_store/composed_dispatcher.rb#4
class RubyEventStore::ComposedDispatcher
  # @return [ComposedDispatcher] a new instance of ComposedDispatcher
  #
  # source://ruby_event_store//lib/ruby_event_store/composed_dispatcher.rb#5
  def initialize(*dispatchers); end

  # source://ruby_event_store//lib/ruby_event_store/composed_dispatcher.rb#9
  def call(subscriber, event, record); end

  # source://ruby_event_store//lib/ruby_event_store/composed_dispatcher.rb#18
  def verify(subscriber); end
end

# source://ruby_event_store//lib/ruby_event_store/correlated_commands.rb#4
class RubyEventStore::CorrelatedCommands
  # @return [CorrelatedCommands] a new instance of CorrelatedCommands
  #
  # source://ruby_event_store//lib/ruby_event_store/correlated_commands.rb#5
  def initialize(event_store, command_bus); end

  # source://ruby_event_store//lib/ruby_event_store/correlated_commands.rb#13
  def call(command); end

  private

  # Returns the value of attribute command_bus.
  #
  # source://ruby_event_store//lib/ruby_event_store/correlated_commands.rb#29
  def command_bus; end

  # Returns the value of attribute event_store.
  #
  # source://ruby_event_store//lib/ruby_event_store/correlated_commands.rb#29
  def event_store; end
end

# source://ruby_event_store//lib/ruby_event_store/correlated_commands.rb#10
class RubyEventStore::CorrelatedCommands::MiniEvent < ::Struct; end

# source://ruby_event_store//lib/ruby_event_store/dispatcher.rb#4
class RubyEventStore::Dispatcher
  # source://ruby_event_store//lib/ruby_event_store/dispatcher.rb#5
  def call(subscriber, event, _); end

  # source://ruby_event_store//lib/ruby_event_store/dispatcher.rb#10
  def verify(subscriber); end
end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#4
class RubyEventStore::Error < ::StandardError; end

# Data structure representing an event
#
# source://ruby_event_store//lib/ruby_event_store/event.rb#7
class RubyEventStore::Event
  # Instantiates a new event
  #
  # @param event_id [String] event id
  # @param data [Hash] event data which belong to your application domain
  # @param metadata [Hash] event metadata which are technical and not
  #   part of your domain such as remote_ip, request_id, correlation_id,
  #   causation_id etc.
  # @return [Event]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#16
  def initialize(event_id: T.unsafe(nil), metadata: T.unsafe(nil), data: T.unsafe(nil)); end

  # Two events are equal if:
  # * they are of the same class
  # * have identical event type
  # * have identical event id
  # * have identical data (verified with eql? method)
  #
  # Event equality ignores metadata!
  #
  # @param other_event [Event, Object] object to compare
  # @return [TrueClass, FalseClass]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#60
  def ==(other_event); end

  # Reads causation_id from metadata.
  # {http://railseventstore.org/docs/correlation_causation/ Find out more}
  #
  # @return [String, nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#104
  def causation_id; end

  # Sets causation_id= in metadata.
  # {http://railseventstore.org/docs/correlation_causation/ Find out more}
  #
  # @param val [String]
  # @return [String]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#113
  def causation_id=(val); end

  # Sets correlation_id and causation_id in metadata based
  # on correlation_id and message_id of the provided message.
  # {http://railseventstore.org/docs/correlation_causation/ Find out more}
  #
  # @param other_message [Event, command] message to correlate with. Most likely an event or a command. Must respond to correlation_id and message_id.
  # @return [String] set causation_id
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#123
  def correlate_with(other_message); end

  # Reads correlation_id from metadata.
  # {http://railseventstore.org/docs/correlation_causation/ Find out more}
  #
  # @return [String, nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#87
  def correlation_id; end

  # Sets correlation_id in metadata.
  # {http://railseventstore.org/docs/correlation_causation/ Find out more}
  #
  # @param val [String]
  # @return [String]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#96
  def correlation_id=(val); end

  # Returns the value of attribute data.
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#22
  def data; end

  # Two events are equal if:
  # * they are of the same class
  # * have identical event type
  # * have identical event id
  # * have identical data (verified with eql? method)
  #
  # Event equality ignores metadata!
  #
  # @param other_event [Event, Object] object to compare
  # @return [TrueClass, FalseClass]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#60
  def eql?(other_event); end

  # Returns the value of attribute event_id.
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#22
  def event_id; end

  # Type of event. Used when matching with subscribed handlers.
  #
  # @return [String]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#32
  def event_type; end

  # Generates a Fixnum hash value for this object. This function
  # have the property that a.eql?(b) implies a.hash == b.hash.
  #
  # The hash value is used along with eql? by the Hash class to
  # determine if two objects reference the same hash key.
  #
  # This hash is based on
  # * class
  # * event_id
  # * data
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#78
  def hash; end

  # Event id
  #
  # @return [String]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#26
  def message_id; end

  # Returns the value of attribute metadata.
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#22
  def metadata; end

  # Timestamp from metadata
  #
  # @return [Time, nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#39
  def timestamp; end

  # Validity time from metadata
  #
  # @return [Time, nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/event.rb#46
  def valid_at; end
end

# @private
#
# source://ruby_event_store//lib/ruby_event_store/event.rb#66
RubyEventStore::Event::BIG_VALUE = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/errors.rb#12
class RubyEventStore::EventDuplicatedInStream < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#17
class RubyEventStore::EventNotFound < ::RubyEventStore::Error
  # @return [EventNotFound] a new instance of EventNotFound
  #
  # source://ruby_event_store//lib/ruby_event_store/errors.rb#20
  def initialize(event_id); end

  # Returns the value of attribute event_id.
  #
  # source://ruby_event_store//lib/ruby_event_store/errors.rb#18
  def event_id; end
end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#15
class RubyEventStore::EventNotFoundInStream < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/expected_version.rb#4
class RubyEventStore::ExpectedVersion
  # @return [ExpectedVersion] a new instance of ExpectedVersion
  #
  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#22
  def initialize(version); end

  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#59
  def ==(other_expected_version); end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#27
  def any?; end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#31
  def auto?; end

  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#59
  def eql?(other_expected_version); end

  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#55
  def hash; end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#35
  def none?; end

  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#39
  def resolve_for(stream, resolver = T.unsafe(nil)); end

  # Returns the value of attribute version.
  #
  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#20
  def version; end

  private

  # @raise [InvalidExpectedVersion]
  #
  # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#67
  def invalid_version!; end

  class << self
    # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#8
    def any; end

    # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#16
    def auto; end

    # source://ruby_event_store//lib/ruby_event_store/expected_version.rb#12
    def none; end
  end
end

# source://ruby_event_store//lib/ruby_event_store/expected_version.rb#52
RubyEventStore::ExpectedVersion::BIG_VALUE = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/expected_version.rb#6
RubyEventStore::ExpectedVersion::NOT_RESOLVED = T.let(T.unsafe(nil), Object)

# source://ruby_event_store//lib/ruby_event_store/expected_version.rb#5
RubyEventStore::ExpectedVersion::POSITION_DEFAULT = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/constants.rb#4
RubyEventStore::GLOBAL_STREAM = T.let(T.unsafe(nil), Object)

# source://ruby_event_store//lib/ruby_event_store/immediate_async_dispatcher.rb#4
class RubyEventStore::ImmediateAsyncDispatcher
  # @return [ImmediateAsyncDispatcher] a new instance of ImmediateAsyncDispatcher
  #
  # source://ruby_event_store//lib/ruby_event_store/immediate_async_dispatcher.rb#5
  def initialize(scheduler:); end

  # source://ruby_event_store//lib/ruby_event_store/immediate_async_dispatcher.rb#9
  def call(subscriber, _, record); end

  # source://ruby_event_store//lib/ruby_event_store/immediate_async_dispatcher.rb#13
  def verify(subscriber); end
end

# source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#5
class RubyEventStore::InMemoryRepository
  # @return [InMemoryRepository] a new instance of InMemoryRepository
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#26
  def initialize(serializer: T.unsafe(nil), ensure_supported_any_usage: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#34
  def append_to_stream(records, stream, expected_version); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#103
  def count(spec); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#69
  def delete_stream(stream); end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#139
  def event_in_stream?(event_id, stream); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#135
  def global_position(event_id); end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#73
  def has_event?(event_id); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#77
  def last_stream_event(stream); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#52
  def link_to_stream(event_ids, stream, expected_version); end

  # @raise [EventNotFoundInStream]
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#129
  def position_in_stream(event_id, stream); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#82
  def read(spec); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#125
  def streams_of(event_id); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#107
  def update_messages(records); end

  private

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#222
  def add_to_stream(stream, serialized_record, resolved_version, index); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#218
  def compute_position(resolved_version, index); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#226
  def ensure_supported_any_usage(resolved_version, stream); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#173
  def event_ids_of_stream(stream); end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#210
  def has_event_in_stream?(event_id, stream_name); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#214
  def index_of(source, event_id); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#192
  def last_stream_version(stream); end

  # Returns the value of attribute mutex.
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#237
  def mutex; end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#181
  def ordered(serialized_records, spec); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#169
  def read_event(event_id); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#145
  def read_scope(spec); end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#177
  def serialized_records_of_stream(stream); end

  # Returns the value of attribute serializer.
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#237
  def serializer; end

  # Returns the value of attribute storage.
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#237
  def storage; end

  # Returns the value of attribute streams.
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#237
  def streams; end

  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#196
  def with_synchronize(expected_version, stream, &block); end
end

# source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#17
class RubyEventStore::InMemoryRepository::EventInStream
  # @return [EventInStream] a new instance of EventInStream
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#18
  def initialize(event_id, position); end

  # Returns the value of attribute event_id.
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#23
  def event_id; end

  # Returns the value of attribute position.
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#23
  def position; end
end

# source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#6
class RubyEventStore::InMemoryRepository::UnsupportedVersionAnyUsage < ::StandardError
  # @return [UnsupportedVersionAnyUsage] a new instance of UnsupportedVersionAnyUsage
  #
  # source://ruby_event_store//lib/ruby_event_store/in_memory_repository.rb#7
  def initialize; end
end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#7
class RubyEventStore::IncorrectStreamData < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/instrumented_dispatcher.rb#4
class RubyEventStore::InstrumentedDispatcher
  # @return [InstrumentedDispatcher] a new instance of InstrumentedDispatcher
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_dispatcher.rb#5
  def initialize(dispatcher, instrumentation); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_dispatcher.rb#10
  def call(subscriber, event, record); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_dispatcher.rb#16
  def method_missing(method_name, *arguments, **keyword_arguments, &block); end

  private

  # Returns the value of attribute dispatcher.
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_dispatcher.rb#30
  def dispatcher; end

  # Returns the value of attribute instrumentation.
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_dispatcher.rb#30
  def instrumentation; end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_dispatcher.rb#24
  def respond_to_missing?(method_name, _include_private); end
end

# source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#4
class RubyEventStore::InstrumentedRepository
  # @return [InstrumentedRepository] a new instance of InstrumentedRepository
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#5
  def initialize(repository, instrumentation); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#10
  def append_to_stream(records, stream, expected_version); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#34
  def count(specification); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#22
  def delete_stream(stream); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#16
  def link_to_stream(event_ids, stream, expected_version); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#52
  def method_missing(method_name, *arguments, **keyword_arguments, &block); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#28
  def read(specification); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#46
  def streams_of(event_id); end

  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#40
  def update_messages(messages); end

  private

  # Returns the value of attribute instrumentation.
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#66
  def instrumentation; end

  # Returns the value of attribute repository.
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#66
  def repository; end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/instrumented_repository.rb#60
  def respond_to_missing?(method_name, _include_private); end
end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#6
class RubyEventStore::InvalidExpectedVersion < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#14
class RubyEventStore::InvalidHandler < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#11
class RubyEventStore::InvalidPageSize < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#9
class RubyEventStore::InvalidPageStart < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#10
class RubyEventStore::InvalidPageStop < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#24
class RubyEventStore::LinkByCausationId < ::RubyEventStore::LinkByMetadata
  # @return [LinkByCausationId] a new instance of LinkByCausationId
  #
  # source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#25
  def initialize(event_store:, prefix: T.unsafe(nil)); end
end

# source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#18
class RubyEventStore::LinkByCorrelationId < ::RubyEventStore::LinkByMetadata
  # @return [LinkByCorrelationId] a new instance of LinkByCorrelationId
  #
  # source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#19
  def initialize(event_store:, prefix: T.unsafe(nil)); end
end

# source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#30
class RubyEventStore::LinkByEventType
  # @return [LinkByEventType] a new instance of LinkByEventType
  #
  # source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#31
  def initialize(event_store:, prefix: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#36
  def call(event); end
end

# source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#4
class RubyEventStore::LinkByMetadata
  # @return [LinkByMetadata] a new instance of LinkByMetadata
  #
  # source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#5
  def initialize(event_store:, key:, prefix: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/link_by_metadata.rb#11
  def call(event); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#4
module RubyEventStore::Mappers; end

# source://ruby_event_store//lib/ruby_event_store/mappers/default.rb#5
class RubyEventStore::Mappers::Default < ::RubyEventStore::Mappers::PipelineMapper
  # @return [Default] a new instance of Default
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/default.rb#6
  def initialize(events_class_remapping: T.unsafe(nil)); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#5
class RubyEventStore::Mappers::EncryptionKey
  # @return [EncryptionKey] a new instance of EncryptionKey
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#6
  def initialize(cipher:, key:); end

  # Returns the value of attribute cipher.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#32
  def cipher; end

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#19
  def decrypt(message, iv); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#11
  def encrypt(message, iv); end

  # Returns the value of attribute key.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#32
  def key; end

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#27
  def random_iv; end

  private

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#36
  def ciphertext_from_authenticated(crypto, message); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#42
  def encrypt_authenticated(crypto, message); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#47
  def prepare_auth_data(crypto); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#58
  def prepare_decrypt(cipher); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_key.rb#52
  def prepare_encrypt(cipher); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/encryption_mapper.rb#5
class RubyEventStore::Mappers::EncryptionMapper < ::RubyEventStore::Mappers::PipelineMapper
  # @return [EncryptionMapper] a new instance of EncryptionMapper
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/encryption_mapper.rb#6
  def initialize(key_repository, serializer: T.unsafe(nil), forgotten_data: T.unsafe(nil)); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#5
class RubyEventStore::Mappers::ForgottenData
  # @return [ForgottenData] a new instance of ForgottenData
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#8
  def initialize(string = T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#16
  def ==(other); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#16
  def eql?(other); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#21
  def method_missing(*_arg0); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#12
  def to_s; end

  private

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#25
  def respond_to_missing?(*_arg0); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/forgotten_data.rb#6
RubyEventStore::Mappers::ForgottenData::FORGOTTEN_DATA = T.let(T.unsafe(nil), String)

# source://ruby_event_store//lib/ruby_event_store/mappers/in_memory_encryption_key_repository.rb#5
class RubyEventStore::Mappers::InMemoryEncryptionKeyRepository
  # @return [InMemoryEncryptionKeyRepository] a new instance of InMemoryEncryptionKeyRepository
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/in_memory_encryption_key_repository.rb#8
  def initialize; end

  # source://ruby_event_store//lib/ruby_event_store/mappers/in_memory_encryption_key_repository.rb#16
  def create(identifier, cipher: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/in_memory_encryption_key_repository.rb#21
  def forget(identifier); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/in_memory_encryption_key_repository.rb#12
  def key_of(identifier, cipher: T.unsafe(nil)); end

  private

  # source://ruby_event_store//lib/ruby_event_store/mappers/in_memory_encryption_key_repository.rb#27
  def prepare_encrypt(cipher); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/in_memory_encryption_key_repository.rb#6
RubyEventStore::Mappers::InMemoryEncryptionKeyRepository::DEFAULT_CIPHER = T.let(T.unsafe(nil), String)

# source://ruby_event_store//lib/ruby_event_store/mappers/instrumented_mapper.rb#5
class RubyEventStore::Mappers::InstrumentedMapper
  # @return [InstrumentedMapper] a new instance of InstrumentedMapper
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/instrumented_mapper.rb#6
  def initialize(mapper, instrumentation); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/instrumented_mapper.rb#11
  def event_to_record(domain_event); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/instrumented_mapper.rb#17
  def record_to_event(record); end

  private

  # Returns the value of attribute instrumentation.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/instrumented_mapper.rb#25
  def instrumentation; end

  # Returns the value of attribute mapper.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/instrumented_mapper.rb#25
  def mapper; end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/json_mapper.rb#5
class RubyEventStore::Mappers::JSONMapper < ::RubyEventStore::Mappers::Default
  # @return [JSONMapper] a new instance of JSONMapper
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/json_mapper.rb#6
  def initialize(events_class_remapping: T.unsafe(nil)); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/null_mapper.rb#5
class RubyEventStore::Mappers::NullMapper < ::RubyEventStore::Mappers::PipelineMapper
  # @return [NullMapper] a new instance of NullMapper
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/null_mapper.rb#6
  def initialize; end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/pipeline.rb#5
class RubyEventStore::Mappers::Pipeline
  # @return [Pipeline] a new instance of Pipeline
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline.rb#6
  def initialize(*transformations, to_domain_event: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline.rb#10
  def dump(domain_event); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline.rb#14
  def load(record); end

  # Returns the value of attribute transformations.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline.rb#18
  def transformations; end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/pipeline_mapper.rb#5
class RubyEventStore::Mappers::PipelineMapper
  # @return [PipelineMapper] a new instance of PipelineMapper
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline_mapper.rb#6
  def initialize(pipeline); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline_mapper.rb#10
  def event_to_record(domain_event); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline_mapper.rb#14
  def record_to_event(record); end

  private

  # Returns the value of attribute pipeline.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/pipeline_mapper.rb#20
  def pipeline; end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/domain_event.rb#5
module RubyEventStore::Mappers::Transformation; end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/domain_event.rb#6
class RubyEventStore::Mappers::Transformation::DomainEvent
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/domain_event.rb#7
  def dump(domain_event); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/domain_event.rb#21
  def load(record); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#6
class RubyEventStore::Mappers::Transformation::Encryption
  # @return [Encryption] a new instance of Encryption
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#20
  def initialize(key_repository, serializer: T.unsafe(nil), forgotten_data: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#26
  def dump(record); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#44
  def load(record); end

  private

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#114
  def decrypt_attribute(data, attribute, meta); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#94
  def decrypt_data(data, meta); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#66
  def deep_dup(hash); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#101
  def encrypt_attribute(data, attribute, meta); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#87
  def encrypt_data(data, meta); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#72
  def encryption_metadata(data, schema); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#62
  def encryption_schema(event_class); end

  # Returns the value of attribute forgotten_data.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#60
  def forgotten_data; end

  # Returns the value of attribute key_repository.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#60
  def key_repository; end

  # Returns the value of attribute serializer.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#60
  def serializer; end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#7
class RubyEventStore::Mappers::Transformation::Encryption::Leaf
  class << self
    # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#8
    def ===(hash); end
  end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#14
class RubyEventStore::Mappers::Transformation::Encryption::MissingEncryptionKey < ::StandardError
  # @return [MissingEncryptionKey] a new instance of MissingEncryptionKey
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/encryption.rb#15
  def initialize(key_identifier); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/event_class_remapper.rb#6
class RubyEventStore::Mappers::Transformation::EventClassRemapper
  # @return [EventClassRemapper] a new instance of EventClassRemapper
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/event_class_remapper.rb#7
  def initialize(class_map); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/event_class_remapper.rb#11
  def dump(record); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/event_class_remapper.rb#15
  def load(record); end

  private

  # Returns the value of attribute class_map.
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/event_class_remapper.rb#28
  def class_map; end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/stringify_metadata_keys.rb#6
class RubyEventStore::Mappers::Transformation::StringifyMetadataKeys
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/stringify_metadata_keys.rb#7
  def dump(record); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/stringify_metadata_keys.rb#11
  def load(record); end

  private

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/stringify_metadata_keys.rb#17
  def stringify(record); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/symbolize_metadata_keys.rb#6
class RubyEventStore::Mappers::Transformation::SymbolizeMetadataKeys
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/symbolize_metadata_keys.rb#7
  def dump(record); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/symbolize_metadata_keys.rb#11
  def load(record); end

  private

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/symbolize_metadata_keys.rb#17
  def symbolize(record); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/upcast.rb#6
class RubyEventStore::Mappers::Transformation::Upcast
  # @return [Upcast] a new instance of Upcast
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/upcast.rb#19
  def initialize(upcast_map); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/upcast.rb#23
  def dump(record); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/upcast.rb#27
  def load(record); end
end

# source://ruby_event_store//lib/ruby_event_store/mappers/transformation/upcast.rb#7
class RubyEventStore::Mappers::Transformation::Upcast::RecordUpcaster
  # @return [RecordUpcaster] a new instance of RecordUpcaster
  #
  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/upcast.rb#8
  def initialize(upcast_map); end

  # source://ruby_event_store//lib/ruby_event_store/mappers/transformation/upcast.rb#12
  def call(record); end
end

# source://ruby_event_store//lib/ruby_event_store/metadata.rb#8
class RubyEventStore::Metadata
  include ::Enumerable
  extend ::Forwardable

  # @return [Metadata] a new instance of Metadata
  #
  # source://ruby_event_store//lib/ruby_event_store/metadata.rb#12
  def initialize(h = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def <(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def <=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def >(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def >=(*args, **_arg1, &block); end

  # @raise [ArgumentError]
  #
  # source://ruby_event_store//lib/ruby_event_store/metadata.rb#17
  def [](key); end

  # @raise [ArgumentError]
  #
  # source://ruby_event_store//lib/ruby_event_store/metadata.rb#22
  def []=(key, val); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def assoc(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def clear(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def compact(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def compact!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete_if(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def dig(*args, **_arg1, &block); end

  # source://ruby_event_store//lib/ruby_event_store/metadata.rb#28
  def each(&block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_key(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_pair(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def each_value(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def empty?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def fetch(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def fetch_values(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def flatten(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def has_key?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def has_value?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def keep_if(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def key(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def key?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def keys(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def rassoc(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def reject!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def select!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def shift(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def size(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def slice(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_proc(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def transform_keys(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def transform_values(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def value?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def values(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def values_at(*args, **_arg1, &block); end

  private

  # source://ruby_event_store//lib/ruby_event_store/metadata.rb#76
  def allowed_types; end
end

# source://ruby_event_store//lib/ruby_event_store/metadata.rb#32
RubyEventStore::Metadata::SAFE_HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://ruby_event_store//lib/ruby_event_store/null.rb#4
module RubyEventStore::NULL
  class << self
    # source://ruby_event_store//lib/ruby_event_store/null.rb#5
    def dump(value); end

    # source://ruby_event_store//lib/ruby_event_store/null.rb#9
    def load(value); end
  end
end

# source://ruby_event_store//lib/ruby_event_store/constants.rb#5
RubyEventStore::PAGE_SIZE = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/projection.rb#4
class RubyEventStore::Projection
  # @return [Projection] a new instance of Projection
  #
  # source://ruby_event_store//lib/ruby_event_store/projection.rb#17
  def initialize(streams: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#44
  def call(event); end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#40
  def current_state; end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#48
  def handled_events; end

  # Returns the value of attribute handlers.
  #
  # source://ruby_event_store//lib/ruby_event_store/projection.rb#23
  def handlers; end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#25
  def init(handler); end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#36
  def initial_state; end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#52
  def run(event_store, start: T.unsafe(nil), count: T.unsafe(nil)); end

  # Returns the value of attribute streams.
  #
  # source://ruby_event_store//lib/ruby_event_store/projection.rb#23
  def streams; end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#30
  def when(events, handler); end

  private

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#78
  def read_scope(event_store, stream, count, start); end

  # @raise [ArgumentError]
  #
  # source://ruby_event_store//lib/ruby_event_store/projection.rb#73
  def reduce_from_all_streams(event_store, start, count); end

  # @raise [ArgumentError]
  #
  # source://ruby_event_store//lib/ruby_event_store/projection.rb#64
  def reduce_from_streams(event_store, start, count); end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#86
  def start_events(start); end

  # source://ruby_event_store//lib/ruby_event_store/projection.rb#90
  def transition(state, event); end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/projection.rb#59
  def valid_starting_point?(start); end

  class << self
    # source://ruby_event_store//lib/ruby_event_store/projection.rb#13
    def from_all_streams; end

    # @raise [ArgumentError]
    #
    # source://ruby_event_store//lib/ruby_event_store/projection.rb#7
    def from_stream(stream_or_streams); end
  end
end

# source://ruby_event_store//lib/ruby_event_store/record.rb#4
class RubyEventStore::Record
  # @raise [StringsRequired]
  # @return [Record] a new instance of Record
  #
  # source://ruby_event_store//lib/ruby_event_store/record.rb#6
  def initialize(event_id:, data:, metadata:, event_type:, timestamp:, valid_at:); end

  # source://ruby_event_store//lib/ruby_event_store/record.rb#25
  def ==(other); end

  # Returns the value of attribute data.
  #
  # source://ruby_event_store//lib/ruby_event_store/record.rb#18
  def data; end

  # source://ruby_event_store//lib/ruby_event_store/record.rb#25
  def eql?(other); end

  # Returns the value of attribute event_id.
  #
  # source://ruby_event_store//lib/ruby_event_store/record.rb#18
  def event_id; end

  # Returns the value of attribute event_type.
  #
  # source://ruby_event_store//lib/ruby_event_store/record.rb#18
  def event_type; end

  # source://ruby_event_store//lib/ruby_event_store/record.rb#21
  def hash; end

  # Returns the value of attribute metadata.
  #
  # source://ruby_event_store//lib/ruby_event_store/record.rb#18
  def metadata; end

  # source://ruby_event_store//lib/ruby_event_store/record.rb#42
  def serialize(serializer); end

  # Returns the value of attribute timestamp.
  #
  # source://ruby_event_store//lib/ruby_event_store/record.rb#18
  def timestamp; end

  # source://ruby_event_store//lib/ruby_event_store/record.rb#31
  def to_h; end

  # Returns the value of attribute valid_at.
  #
  # source://ruby_event_store//lib/ruby_event_store/record.rb#18
  def valid_at; end
end

# source://ruby_event_store//lib/ruby_event_store/record.rb#20
RubyEventStore::Record::BIG_VALUE = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/record.rb#5
class RubyEventStore::Record::StringsRequired < ::StandardError; end

# source://ruby_event_store//lib/ruby_event_store/errors.rb#13
class RubyEventStore::ReservedInternalName < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#4
class RubyEventStore::SerializedRecord
  # @raise [StringsRequired]
  # @return [SerializedRecord] a new instance of SerializedRecord
  #
  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#6
  def initialize(event_id:, data:, metadata:, event_type:, timestamp:, valid_at:); end

  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#24
  def ==(other); end

  # Returns the value of attribute data.
  #
  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#17
  def data; end

  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#41
  def deserialize(serializer); end

  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#24
  def eql?(other); end

  # Returns the value of attribute event_id.
  #
  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#17
  def event_id; end

  # Returns the value of attribute event_type.
  #
  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#17
  def event_type; end

  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#20
  def hash; end

  # Returns the value of attribute metadata.
  #
  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#17
  def metadata; end

  # Returns the value of attribute timestamp.
  #
  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#17
  def timestamp; end

  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#30
  def to_h; end

  # Returns the value of attribute valid_at.
  #
  # source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#17
  def valid_at; end
end

# source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#19
RubyEventStore::SerializedRecord::BIG_VALUE = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/serialized_record.rb#5
class RubyEventStore::SerializedRecord::StringsRequired < ::StandardError; end

# source://ruby_event_store//lib/ruby_event_store/serializers/yaml.rb#6
module RubyEventStore::Serializers; end

# source://ruby_event_store//lib/ruby_event_store/serializers/yaml.rb#7
class RubyEventStore::Serializers::YAML
  class << self
    # source://ruby_event_store//lib/ruby_event_store/serializers/yaml.rb#8
    def dump(value); end

    # source://ruby_event_store//lib/ruby_event_store/serializers/yaml.rb#12
    def load(serialized); end
  end
end

# Used for building and executing the query specification.
#
# source://ruby_event_store//lib/ruby_event_store/specification.rb#5
class RubyEventStore::Specification
  # @api private
  # @private
  # @return [Specification] a new instance of Specification
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#10
  def initialize(reader, result = T.unsafe(nil)); end

  # Sets the order of time sorting using transaction time
  # {http://railseventstore.org/docs/read/ Find out more}
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#127
  def as_at; end

  # Sets the order of time sorting using validity time
  # {http://railseventstore.org/docs/read/ Find out more}
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#135
  def as_of; end

  # Sets the order of reading events to descending (backward from the start).
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#151
  def backward; end

  # Limits the query to events within given time range.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param time_range [Range]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#115
  def between(time_range); end

  # Calculates the size of result set based on the specification build up to this point.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Integer] Number of events to read
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#214
  def count; end

  # Executes the query based on the specification built up to this point.
  # Yields events read from the store if block given. Otherwise, returns enumerable collection.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Enumerator, nil] Enumerator is returned when block not given
  # @yield [Event] event
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#183
  def each; end

  # Executes the query based on the specification built up to this point.
  # Yields each batch of records that was retrieved from the store.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Enumerator, nil] Enumerator is returned when block not given
  # @yield [Array<Event>] batch of events
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#171
  def each_batch; end

  # Reads single event from repository.
  # Returns the event with specified id or nil if event is not found
  # in specified collection of events.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Event, nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#310
  def event(event_id); end

  # Reads single existing event from repository.
  # Returns the event with specified id or raises [EventNotFound] error if
  # event is not found in specified collection of events.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Event]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#320
  def event!(event_id); end

  # Reads all events of given ids from repository.
  # Yields each event (found by id in specified collection of events)
  # read from the store if block given. Otherwise, returns enumerable collection.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Enumerator] Enumerator is returned when block not given
  # @yield [Event] event
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#331
  def events(event_ids); end

  # Executes the query based on the specification built up to this point.
  # Returns the first event in specified collection of events.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Event, nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#272
  def first; end

  # Sets the order of reading events to ascending (forward from the start).
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#143
  def forward; end

  # Limits the query to events before or after another event.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param start [String] id of event to start reading from.
  # @raise [InvalidPageStart]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#29
  def from(start); end

  # Specifies that events should be obtained in batches.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # Looping through a collection of events from the store
  # can be inefficient since it will try to instantiate all
  # the events at once.
  #
  # In that case, batch processing methods allow you to work
  # with the records in batches, thereby greatly reducing
  # memory consumption.
  #
  # @param batch_size [Integer] number of events to read in a single batch
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#240
  def in_batches(batch_size = T.unsafe(nil)); end

  # Specifies that events should be obtained in batches.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # Looping through a collection of events from the store
  # can be inefficient since it will try to instantiate all
  # the events at once.
  #
  # In that case, batch processing methods allow you to work
  # with the records in batches, thereby greatly reducing
  # memory consumption.
  #
  # @param batch_size [Integer] number of events to read in a single batch
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#240
  def in_batches_of(batch_size = T.unsafe(nil)); end

  # Executes the query based on the specification built up to this point.
  # Returns the last event in specified collection of events.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Event, nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#281
  def last; end

  # Limits the query to specified number of events.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param count [Integer] maximal number of events to retrieve
  # @raise [InvalidPageSize]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#160
  def limit(count); end

  # Executes the query based on the specification built up to this point
  # and maps the result using provided block.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @raise [ArgumentError]
  # @return [Array] of mapped result
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#194
  def map(&block); end

  # Limits the query to events that occurred earlier than given time.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param time [Time]
  # @raise [ArgumentError]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#83
  def newer_than(time); end

  # Limits the query to events that occurred on given time or earlier.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param time [Time]
  # @raise [ArgumentError]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#99
  def newer_than_or_equal(time); end

  # Limits the query to certain event type(s).
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#290
  def of_type(*types); end

  # Limits the query to certain event type(s).
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#290
  def of_types(*types); end

  # Limits the query to events that later than given time.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param time [Time]
  # @raise [ArgumentError]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#51
  def older_than(time); end

  # Limits the query to events that occurred on given time or later.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param time [Time]
  # @raise [ArgumentError]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#67
  def older_than_or_equal(time); end

  # Specifies that only first event should be read.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#255
  def read_first; end

  # Specifies that only last event should be read.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#263
  def read_last; end

  # Reduces the results of the query based on the specification
  # built up to this point result using provided block.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param accumulator starting state for reduce operation
  # @raise [ArgumentError]
  # @return reduce result as defined by block given
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#205
  def reduce(accumulator = T.unsafe(nil), &block); end

  # Returns the value of attribute result.
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#335
  def result; end

  # Limits the query to certain stream.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param stream_name [String] name of the stream to get events from
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#20
  def stream(stream_name); end

  # Limits the query to events before or after another event.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param stop [String] id of event to start reading from.
  # @raise [InvalidPageStop]
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#40
  def to(stop); end

  # Executes the query based on the specification built up to this point.
  # Returns array of domain events.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Array<Event>]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#223
  def to_a; end

  # Limits the query to certain events by given even ids.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @param event_ids [Array(String)] ids of event to look for.
  # @return [Specification]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#300
  def with_id(event_ids); end

  private

  # Returns the value of attribute reader.
  #
  # source://ruby_event_store//lib/ruby_event_store/specification.rb#339
  def reader; end
end

# source://ruby_event_store//lib/ruby_event_store/specification.rb#6
RubyEventStore::Specification::DEFAULT_BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# Used for fetching events based on given query specification.
#
# source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#5
class RubyEventStore::SpecificationReader
  # @api private
  # @private
  # @return [SpecificationReader] a new instance of SpecificationReader
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#8
  def initialize(repository, mapper); end

  # @api private
  # @private
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#28
  def count(specification_result); end

  # @api private
  # @private
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#22
  def each(specification_result); end

  # @api private
  # @private
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#34
  def has_event?(event_id); end

  # @api private
  # @private
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#15
  def one(specification_result); end

  private

  # Returns the value of attribute mapper.
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#40
  def mapper; end

  # Returns the value of attribute repository.
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_reader.rb#40
  def repository; end
end

# source://ruby_event_store//lib/ruby_event_store/specification_result.rb#4
class RubyEventStore::SpecificationResult
  # @return [SpecificationResult] a new instance of SpecificationResult
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#5
  def initialize(direction: T.unsafe(nil), start: T.unsafe(nil), stop: T.unsafe(nil), older_than: T.unsafe(nil), older_than_or_equal: T.unsafe(nil), newer_than: T.unsafe(nil), newer_than_or_equal: T.unsafe(nil), time_sort_by: T.unsafe(nil), count: T.unsafe(nil), stream: T.unsafe(nil), read_as: T.unsafe(nil), batch_size: T.unsafe(nil), with_ids: T.unsafe(nil), with_types: T.unsafe(nil)); end

  # Two specification attributess are equal if:
  # * they are of the same class
  # * have identical data (verified with eql? method)
  #
  # @param other_spec [SpecificationResult, Object] object to compare
  # @return [TrueClass, FalseClass]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#243
  def ==(other_spec); end

  # Read strategy. True if all items will be read
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#222
  def all?; end

  # Read direction. True is reading backward
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#150
  def backward?; end

  # Size of batch to read (only for :batch read strategy)
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Integer]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#158
  def batch_size; end

  # Read strategy. True if items will be read in batches
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#198
  def batched?; end

  # Clone [SpecificationResult]
  # If block is given cloned attributes might be modified.
  #
  # @return [SpecificationResult]
  # @yield [new_attributes]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#230
  def dup; end

  # Read strategy. True if first item will be read
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#206
  def first?; end

  # Read direction. True is reading forward
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#142
  def forward?; end

  # Generates a Fixnum hash value for this object. This function
  # have the property that a.eql?(b) implies a.hash == b.hash.
  #
  # The hash value is used along with eql? by the Hash class to
  # determine if two objects reference the same hash key.
  #
  # This hash is based on
  # * class
  # * direction
  # * start
  # * stop
  # * older_than
  # * older_than_or_equal
  # * newer_than
  # * newer_than_or_equal
  # * time_sort_by
  # * count
  # * stream
  # * read_as
  # * batch_size
  # * with_ids
  # * with_types
  #
  # @return [Integer]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#274
  def hash; end

  # Read strategy. True if last item will be read
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#214
  def last?; end

  # Results limit or infinity if limit not defined
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Integer|Infinity]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#70
  def limit; end

  # Limited results. True if number of read elements are limited
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#62
  def limit?; end

  # Starting time.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Time]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#118
  def newer_than; end

  # Starting time.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Time]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#126
  def newer_than_or_equal; end

  # Ending time.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Time]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#102
  def older_than; end

  # Ending time.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Time]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#110
  def older_than_or_equal; end

  # Starting position. Event id of starting event
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [String]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#86
  def start; end

  # Stop position. Event id of stopping event
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [String|Symbol]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#94
  def stop; end

  # Stream definition. Stream to be read or nil
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Stream|nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#78
  def stream; end

  # Time sorting strategy. Nil when not specified.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Symbol]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#134
  def time_sort_by; end

  # Ids of specified event to be read (if any given)
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Array|nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#166
  def with_ids; end

  # Read by specified ids. True if event ids have been specified.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#174
  def with_ids?; end

  # Event types to be read (if any given)
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Array|nil]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#182
  def with_types; end

  # Read by specified event types. True if event types have been specified.
  # {http://railseventstore.org/docs/read/ Find out more}.
  #
  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#190
  def with_types?; end

  private

  # Returns the value of attribute attributes.
  #
  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#296
  def attributes; end

  # source://ruby_event_store//lib/ruby_event_store/specification_result.rb#298
  def get_direction; end
end

# @private
#
# source://ruby_event_store//lib/ruby_event_store/specification_result.rb#248
RubyEventStore::SpecificationResult::BIG_VALUE = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/stream.rb#4
class RubyEventStore::Stream
  # @raise [IncorrectStreamData]
  # @return [Stream] a new instance of Stream
  #
  # source://ruby_event_store//lib/ruby_event_store/stream.rb#5
  def initialize(name); end

  # source://ruby_event_store//lib/ruby_event_store/stream.rb#21
  def ==(other_stream); end

  # source://ruby_event_store//lib/ruby_event_store/stream.rb#21
  def eql?(other_stream); end

  # @return [Boolean]
  #
  # source://ruby_event_store//lib/ruby_event_store/stream.rb#10
  def global?; end

  # source://ruby_event_store//lib/ruby_event_store/stream.rb#17
  def hash; end

  # Returns the value of attribute name.
  #
  # source://ruby_event_store//lib/ruby_event_store/stream.rb#14
  def name; end
end

# source://ruby_event_store//lib/ruby_event_store/stream.rb#16
RubyEventStore::Stream::BIG_VALUE = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/errors.rb#8
class RubyEventStore::SubscriberNotExist < ::RubyEventStore::Error; end

# source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#6
class RubyEventStore::Subscriptions
  # @return [Subscriptions] a new instance of Subscriptions
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#7
  def initialize(event_type_resolver: T.unsafe(nil)); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#18
  def add_global_subscription(subscriber); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#14
  def add_subscription(subscriber, event_types); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#26
  def add_thread_global_subscription(subscriber); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#22
  def add_thread_subscription(subscriber, event_types); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#30
  def all_for(event_type); end

  # Returns the value of attribute event_type_resolver.
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#34
  def event_type_resolver; end

  private

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#40
  def default_event_type_resolver; end

  # Returns the value of attribute global.
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#38
  def global; end

  # Returns the value of attribute local.
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#38
  def local; end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#48
  def resolve_event_type(type); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#44
  def resolve_event_types(event_types); end

  # Returns the value of attribute thread.
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#38
  def thread; end
end

# source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#79
class RubyEventStore::Subscriptions::GlobalSubscriptions
  # @return [GlobalSubscriptions] a new instance of GlobalSubscriptions
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#80
  def initialize; end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#84
  def add(subscription); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#89
  def all_for(_event_type); end
end

# source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#64
class RubyEventStore::Subscriptions::LocalSubscriptions
  # @return [LocalSubscriptions] a new instance of LocalSubscriptions
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#65
  def initialize; end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#69
  def add(subscription, event_types); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#74
  def all_for(event_type); end
end

# source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#109
class RubyEventStore::Subscriptions::ThreadGlobalSubscriptions
  # @return [ThreadGlobalSubscriptions] a new instance of ThreadGlobalSubscriptions
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#110
  def initialize; end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#114
  def add(subscription); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#119
  def all_for(_event_type); end
end

# source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#94
class RubyEventStore::Subscriptions::ThreadLocalSubscriptions
  # @return [ThreadLocalSubscriptions] a new instance of ThreadLocalSubscriptions
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#95
  def initialize; end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#99
  def add(subscription, event_types); end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#104
  def all_for(event_type); end
end

# source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#52
class RubyEventStore::Subscriptions::ThreadSubscriptions
  # @return [ThreadSubscriptions] a new instance of ThreadSubscriptions
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#53
  def initialize; end

  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#59
  def all_for(event_type); end

  # Returns the value of attribute global.
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#57
  def global; end

  # Returns the value of attribute local.
  #
  # source://ruby_event_store//lib/ruby_event_store/subscriptions.rb#57
  def local; end
end

# source://ruby_event_store//lib/ruby_event_store/constants.rb#6
RubyEventStore::TIMESTAMP_PRECISION = T.let(T.unsafe(nil), Integer)

# source://ruby_event_store//lib/ruby_event_store/transform_keys.rb#4
class RubyEventStore::TransformKeys
  class << self
    # source://ruby_event_store//lib/ruby_event_store/transform_keys.rb#6
    def stringify(data); end

    # source://ruby_event_store//lib/ruby_event_store/transform_keys.rb#10
    def symbolize(data); end

    private

    # source://ruby_event_store//lib/ruby_event_store/transform_keys.rb#16
    def deep_transform(data, &block); end
  end
end

# source://ruby_event_store//lib/ruby_event_store/version.rb#4
RubyEventStore::VERSION = T.let(T.unsafe(nil), String)

# source://ruby_event_store//lib/ruby_event_store/errors.rb#5
class RubyEventStore::WrongExpectedEventVersion < ::RubyEventStore::Error; end
