# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-types` gem.
# Please instead update this file by running `bin/tapioca gem dry-types`.

# Main library namespace
#
# @api public
#
# source://dry-types//lib/dry/types/version.rb#3
module Dry
  class << self
    # source://dry-core/0.7.1/lib/dry/core/equalizer.rb#11
    def Equalizer(*keys, **options); end

    # source://dry-struct/1.4.0/lib/dry/struct.rb#33
    def Struct(attributes = T.unsafe(nil), &block); end

    # Export registered types as a module with constants
    #
    # @api public
    # @example no options
    #
    #   module Types
    #   # imports all types as constants, uses modules for namespaces
    #   include Dry::Types()
    #   end
    #   # strict types are exported by default
    #   Types::Integer
    #   # => #<Dry::Types[Constrained<Nominal<Integer> rule=[type?(Integer)]>]>
    #   Types::Nominal::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example changing default types
    #
    #   module Types
    #   include Dry::Types(default: :nominal)
    #   end
    #   Types::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example cherry-picking namespaces
    #
    #   module Types
    #   include Dry::Types(:strict, :coercible)
    #   end
    #   # cherry-picking discards default types,
    #   # provide the :default option along with the list of
    #   # namespaces if you want the to be exported
    #   Types.constants # => [:Coercible, :Strict]
    # @example custom names
    #   module Types
    #   include Dry::Types(coercible: :Kernel)
    #   end
    #   Types::Kernel::Integer
    #   # => #<Dry::Types[Constructor<Nominal<Integer> fn=Kernel.Integer>]>
    # @param namespaces [Array<Symbol>] List of type namespaces to export
    # @param default [Symbol] Default namespace to export
    # @param aliases [Hash{Symbol => Symbol}] Optional renamings, like strict: :Draconian
    # @return [Dry::Types::Module]
    # @see Dry::Types::Module
    #
    # source://dry-types//lib/dry/types.rb#226
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# @api public
# @see Dry.Types
#
# source://dry-types//lib/dry/types/version.rb#4
module Dry::Types
  include ::Dry::Core::Constants
  extend ::Dry::Core::Deprecations::Interface
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::Dry::Core::Extensions

  class << self
    # @api public
    # @param options [Hash]
    # @return [Dry::Logic::Rule]
    #
    # source://dry-types//lib/dry/types/constraints.rb#17
    def Rule(options); end

    # Get a built-in type by its name
    #
    # @api public
    # @param name [String, Class]
    # @return [Type, Class]
    #
    # source://dry-types//lib/dry/types.rb#88
    def [](name); end

    # @api private
    #
    # source://dry-types//lib/dry/types.rb#136
    def const_missing(const); end

    # Return container with registered built-in type objects
    #
    # @api private
    # @return [Container{String => Nominal}]
    #
    # source://dry-types//lib/dry/types.rb#55
    def container; end

    # Add a new type builder method. This is a public API for defining custom
    # type constructors
    #
    # @api public
    # @example simple custom type constructor
    #   Dry::Types.define_builder(:or_nil) do |type|
    #   type.optional.fallback(nil)
    #   end
    #
    #   Dry::Types["integer"].or_nil.("foo") # => nil
    # @example fallback alias
    #   Dry::Types.define_builder(:or) do |type, fallback|
    #   type.fallback(fallback)
    #   end
    #
    #   Dry::Types["integer"].or(100).("foo") # => 100
    # @param method [Symbol]
    # @param block [#call]
    #
    # source://dry-types//lib/dry/types.rb#170
    def define_builder(method, &block); end

    # Infer a type identifier from the provided class
    #
    # @api public
    # @param klass [#to_s]
    # @return [String]
    #
    # source://dry-types//lib/dry/types.rb#122
    def identifier(klass); end

    # @api private
    # @private
    #
    # source://dry-types//lib/dry/types.rb#46
    def included(*_arg0); end

    # @api public
    #
    # source://dry-core/0.7.1/lib/dry/core/deprecations.rb#202
    def module(*args, &block); end

    # Register a new built-in type
    #
    # @api private
    # @param name [String]
    # @param type [Type]
    # @param block [#call, nil]
    # @return [Container{String => Nominal}]
    #
    # source://dry-types//lib/dry/types.rb#77
    def register(name, type = T.unsafe(nil), &block); end

    # Check if a give type is registered
    #
    # @api private
    # @return [Boolean]
    #
    # source://dry-types//lib/dry/types.rb#64
    def registered?(class_or_identifier); end

    # @api private
    # @return [Dry::Logic::RuleCompiler]
    #
    # source://dry-types//lib/dry/types/constraints.rb#30
    def rule_compiler; end

    # Cached type map
    #
    # @api private
    # @return [Concurrent::Map]
    #
    # source://dry-types//lib/dry/types.rb#131
    def type_map; end
  end
end

# All built-in primitives
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#40
Dry::Types::ALL_PRIMITIVES = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/any.rb#45
Dry::Types::Any = T.let(T.unsafe(nil), Dry::Types::AnyClass)

# Any is a nominal type that defines Object as the primitive class
#
# This type is useful in places where you can't be specific about the type
# and anything is acceptable.
#
# @api public
#
# source://dry-types//lib/dry/types/any.rb#11
class Dry::Types::AnyClass < ::Dry::Types::Nominal
  # @api private
  # @return [AnyClass] a new instance of AnyClass
  #
  # source://dry-types//lib/dry/types/any.rb#17
  def initialize(**options); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/any.rb#24
  def name; end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/any.rb#40
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param new_options [Hash]
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/any.rb#33
  def with(**new_options); end

  class << self
    # @api public
    #
    # source://dry-types//lib/dry/types/any.rb#12
    def name; end
  end
end

# Array type can be used to define an array with optional member type
#
# @api public
#
# source://dry-types//lib/dry/types/array/constructor.rb#9
class Dry::Types::Array < ::Dry::Types::Nominal
  # @api private
  #
  # source://dry-types//lib/dry/types/array.rb#30
  def constructor_type; end

  # Build an array type with a member type
  #
  # @api public
  # @param type [Type, #call]
  # @return [Array::Member]
  #
  # source://dry-types//lib/dry/types/array.rb#19
  def of(type); end
end

# @api private
#
# source://dry-types//lib/dry/types/array/constructor.rb#11
class Dry::Types::Array::Constructor < ::Dry::Types::Constructor
  # @api private
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#12
  def constructor_type; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#19
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#26
  def of(member); end
end

# Member arrays define their member type that is applied to each element
#
# @api public
#
# source://dry-types//lib/dry/types/array/member.rb#12
class Dry::Types::Array::Member < ::Dry::Types::Array
  # @api private
  # @option options
  # @param primitive [Class]
  # @param options [Hash]
  # @return [Member] a new instance of Member
  #
  # source://dry-types//lib/dry/types/array/member.rb#21
  def initialize(primitive, **options); end

  # @api private
  # @param input [Object]
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/array/member.rb#47
  def call_safe(input); end

  # @api private
  # @param input [Object]
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/array/member.rb#31
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/array/member.rb#118
  def constructor_type; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/array/member.rb#102
  def lax; end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/array/member.rb#13
  def member; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/array/member.rb#109
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Array, Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/array/member.rb#75
  def try(input, &block); end
end

# Common API for building types and composition
#
# @api public
#
# source://dry-types//lib/dry/types/builder.rb#10
module Dry::Types::Builder
  include ::Dry::Core::Constants

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def <<(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def append(constructor = T.unsafe(nil), **options, &block); end

  # Turn a type into a constrained type
  #
  # @api public
  # @param options [Hash] constraining rule (see {Types.Rule})
  # @return [Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#55
  def constrained(options); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/builder.rb#16
  def constrained_type; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/builder.rb#23
  def constructor_type; end

  # Turn a type into a type with a default value
  #
  # @api public
  # @option [Boolean]
  # @param input [Object]
  # @param block [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @raise [ConstraintError]
  # @return [Default]
  #
  # source://dry-types//lib/dry/types/builder.rb#70
  def default(input = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Define an enum on top of the existing type
  #
  # @api public
  # @param values [Array]
  # @return [Enum]
  #
  # source://dry-types//lib/dry/types/builder.rb#103
  def enum(*values); end

  # Use the given value on type mismatch
  #
  # @api public
  # @option [Boolean]
  # @param value [Object]
  # @param fallback [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#150
  def fallback(value = T.unsafe(nil), shared: T.unsafe(nil), &_fallback); end

  # Turn a type into a lax type that will rescue from type-errors and
  # return the original input
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/builder.rb#120
  def lax; end

  # Turn a type into an optional type
  #
  # @api public
  # @return [Sum]
  #
  # source://dry-types//lib/dry/types/builder.rb#44
  def optional; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def prepend(constructor = T.unsafe(nil), **options, &block); end

  # Compose two types into a Sum type
  #
  # @api private
  # @param other [Type]
  # @return [Sum, Sum::Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#34
  def |(other); end
end

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Builder::Undefined = T.let(T.unsafe(nil), Object)

# Common API for building type objects in a convenient way
#
# @api public
#
# source://dry-types//lib/dry/types/builder_methods.rb#9
module Dry::Types::BuilderMethods
  # Build an array type.
  #
  # Shortcut for Array#of.
  #
  # @api public
  # @example
  #   Types::Strings = Types.Array(Types::String)
  # @param type [Dry::Types::Type]
  # @return [Dry::Types::Array]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#26
  def Array(type); end

  # Build a type with a single value
  # The equality check done with `equal?`
  #
  # @api public
  # @param object [Object]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#71
  def Constant(object); end

  # Build a constructor type
  # If no constructor block given it uses .new method
  #
  # @api public
  # @param klass [Class]
  # @param cons [#call, nil] Value constructor
  # @param block [#call, nil] Value constructor
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#83
  def Constructor(klass, cons = T.unsafe(nil), &block); end

  # Build a hash schema
  #
  # @api public
  # @param type_map [Hash{Symbol => Dry::Types::Type}]
  # @return [Dry::Types::Array]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#35
  def Hash(type_map); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#50
  def Instance(klass); end

  # Builds a constrained nominal type accepting any value that
  # responds to given methods
  #
  # @api public
  # @example
  #   Types::Callable = Types.Interface(:call)
  #   Types::Contact = Types.Interface(:name, :address)
  # @param methods [Array<String, Symbol>] Method names
  # @return [Dry::Types::Contrained]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#134
  def Interface(*methods); end

  # Build a map type
  #
  # @api public
  # @example
  #   Types::IntMap = Types.Map(Types::Strict::Integer, 'any')
  #   Types::IntStringMap = Types.Map(Types::Strict::Integer, Types::Strict::String)
  # @param key_type [Type] Key type
  # @param value_type [Type] Value type
  # @return [Dry::Types::Map]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#120
  def Map(key_type, value_type); end

  # Build a nominal type
  #
  # @api public
  # @param klass [Class]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#100
  def Nominal(klass); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#50
  def Strict(klass); end

  # Build a type with a single value
  # The equality check done with `eql?`
  #
  # @api public
  # @param value [Object]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#61
  def Value(value); end

  # @api private
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#11
  def included(base); end
end

# All coercible types
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#43
Dry::Types::COERCIBLE = T.let(T.unsafe(nil), Hash)

# Base class for coercion errors raise by dry-types
#
# @api public
#
# source://dry-types//lib/dry/types/errors.rb#16
class Dry::Types::CoercionError < ::StandardError
  # @api private
  # @return [CoercionError] a new instance of CoercionError
  #
  # source://dry-types//lib/dry/types/errors.rb#35
  def initialize(message, meta: T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # Metadata associated with the error
  #
  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#32
  def meta; end

  class << self
    # @api private
    #
    # source://dry-types//lib/dry/types/errors.rb#17
    def handle(exception, meta: T.unsafe(nil)); end
  end
end

# Common coercion functions used by the built-in `Params` and `JSON` types
#
# @api public
#
# source://dry-types//lib/dry/types/coercions.rb#8
module Dry::Types::Coercions
  include ::Dry::Core::Constants

  # @api public
  # @param input [#to_str, Object]
  # @return [Date, Object]
  # @see Date.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#18
  def to_date(input, &block); end

  # @api public
  # @param input [#to_str, Object]
  # @return [DateTime, Object]
  # @see DateTime.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#41
  def to_date_time(input, &block); end

  # @api public
  # @param input [#to_sym, Object]
  # @raise CoercionError
  # @return [Symbol, Object]
  #
  # source://dry-types//lib/dry/types/coercions.rb#87
  def to_symbol(input, &block); end

  # @api public
  # @param input [#to_str, Object]
  # @return [Time, Object]
  # @see Time.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#64
  def to_time(input, &block); end

  private

  # Checks whether String is empty
  #
  # @api private
  # @param value [String, Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/coercions.rb#102
  def empty_str?(value); end
end

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::IDENTITY = T.let(T.unsafe(nil), Proc)

# JSON-specific coercions
#
# @api public
#
# source://dry-types//lib/dry/types/coercions/json.rb#14
module Dry::Types::Coercions::JSON
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil]
    #
    # source://dry-types//lib/dry/types/coercions/json.rb#41
    def to_decimal(input, &_block); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is nil
    #
    # source://dry-types//lib/dry/types/coercions/json.rb#24
    def to_nil(input, &_block); end
  end
end

# Params-specific coercions
#
# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#12
module Dry::Types::Coercions::Params
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [Array, String, Object]
    # @raise CoercionError
    # @return [Array, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#134
    def to_ary(input, &_block); end

    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#115
    def to_decimal(input, &_block); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#68
    def to_false(input, &_block); end

    # @api public
    # @param input [#to_f, Object]
    # @raise CoercionError
    # @return [Float, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#102
    def to_float(input, &block); end

    # @api public
    # @param input [Hash, String, Object]
    # @raise CoercionError
    # @return [Hash, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#153
    def to_hash(input, &_block); end

    # @api public
    # @param input [#to_int, #to_i, Object]
    # @raise CoercionError
    # @return [Integer, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#85
    def to_int(input, &block); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is an empty string or nil
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#28
    def to_nil(input, &_block); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#48
    def to_true(input, &_block); end
  end
end

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#15
Dry::Types::Coercions::Params::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#14
Dry::Types::Coercions::Params::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#13
Dry::Types::Coercions::Params::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Coercions::Undefined = T.let(T.unsafe(nil), Object)

# @api private
#
# source://dry-types//lib/dry/types/compiler.rb#8
class Dry::Types::Compiler
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Compiler] a new instance of Compiler
  #
  # source://dry-types//lib/dry/types/compiler.rb#13
  def initialize(registry); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#17
  def call(ast); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#118
  def compile_fn(fn); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#11
  def registry; end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#21
  def visit(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#114
  def visit_any(meta); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#63
  def visit_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#26
  def visit_constrained(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#32
  def visit_constructor(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#104
  def visit_enum(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#69
  def visit_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#84
  def visit_json_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#79
  def visit_json_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#99
  def visit_key(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#38
  def visit_lax(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#109
  def visit_map(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#43
  def visit_nominal(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#94
  def visit_params_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#89
  def visit_params_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#54
  def visit_rule(node); end

  # source://dry-core/0.7.1/lib/dry/core/deprecations.rb#168
  def visit_safe(*args, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#74
  def visit_schema(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#58
  def visit_sum(node); end
end

# Constrained types apply rules to the input
#
# @api public
#
# source://dry-types//lib/dry/types/constrained/coercible.rb#5
class Dry::Types::Constrained
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param type [Type]
  # @param options [Hash]
  # @return [Constrained] a new instance of Constrained
  #
  # source://dry-types//lib/dry/types/constrained.rb#28
  def initialize(type, **options); end

  # @api public
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constrained.rb#108
  def ===(value); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained.rb#49
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained.rb#36
  def call_unsafe(input); end

  # @api public
  # @param options [Hash] The options hash provided to {Types.Rule} and combined
  #   using {&} with previous {#rule}
  # @return [Constrained]
  # @see Dry::Logic::Operators#and
  #
  # source://dry-types//lib/dry/types/constrained.rb#92
  def constrained(options); end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/constrained.rb#99
  def constrained?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constrained.rb#127
  def constructor_type; end

  # Build lax type. Constraints are not applicable to lax types hence unwrapping
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/constrained.rb#116
  def lax; end

  # @api public
  # @return [Dry::Logic::Rule]
  #
  # source://dry-types//lib/dry/types/constrained.rb#21
  def rule; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/constrained.rb#122
  def to_ast(meta: T.unsafe(nil)); end

  # Safe coercion attempt. It is similar to #call with a
  # block given but returns a Result instance with metadata
  # about errors (if any).
  #
  # @api public
  # @overload try
  # @overload try
  #
  # source://dry-types//lib/dry/types/constrained.rb#72
  def try(input, &block); end

  private

  # @api private
  # @param response [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constrained.rb#138
  def decorate?(response); end
end

# Common coercion-related API for constrained types
#
# @api public
#
# source://dry-types//lib/dry/types/constrained/coercible.rb#12
class Dry::Types::Constrained::Coercible < ::Dry::Types::Constrained
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#27
  def call_safe(input); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#13
  def call_unsafe(input); end

  # @api public
  # @see Dry::Types::Constrained#try
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#40
  def try(input, &block); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#105
class Dry::Types::ConstraintError < ::Dry::Types::CoercionError
  # @api public
  # @param result [String, #to_s]
  # @param input [Object]
  # @return [ConstraintError] a new instance of ConstraintError
  #
  # source://dry-types//lib/dry/types/errors.rb#112
  def initialize(result, input); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#108
  def input; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/errors.rb#124
  def message; end

  # @api public
  # @return [String, #to_s]
  #
  # source://dry-types//lib/dry/types/errors.rb#106
  def result; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/errors.rb#124
  def to_s; end
end

# Constructor types apply a function to the input that is supposed to return
# a new value. Coercion is a common use case for constructor types.
#
# @api public
#
# source://dry-types//lib/dry/types/constructor/function.rb#11
class Dry::Types::Constructor < ::Dry::Types::Nominal
  # Instantiate a new constructor type instance
  #
  # @api private
  # @param type [Type]
  # @param fn [Function]
  # @param options [Hash]
  # @return [Constructor] a new instance of Constructor
  #
  # source://dry-types//lib/dry/types/constructor.rb#68
  def initialize(type, fn: T.unsafe(nil), **options); end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#150
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#115
  def >>(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#115
  def append(new_fn = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor.rb#78
  def call_safe(input); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor.rb#86
  def call_unsafe(input); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/constructor.rb#130
  def constrained_type; end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#115
  def constructor(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [#call]
  #
  # source://dry-types//lib/dry/types/constructor.rb#18
  def fn; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/constructor.rb#159
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#150
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/constructor.rb#137
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/constructor.rb#168
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/constructor.rb#97
  def try(input, &block); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/constructor.rb#21
  def type; end

  private

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param method [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  #
  # source://dry-types//lib/dry/types/constructor.rb#190
  def method_missing(method, *args, &block); end

  # @api private
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constructor.rb#179
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    #
    # source://dry-types//lib/dry/types/constructor.rb#40
    def [](type, fn:, **options); end

    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    #
    # source://dry-types//lib/dry/types/constructor.rb#30
    def new(input, **options, &block); end

    # @api private
    #
    # source://dry-types//lib/dry/types/constructor.rb#51
    def wrapper_type; end
  end
end

# Function is used internally by Constructor types
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#12
class Dry::Types::Constructor::Function
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Function] a new instance of Function
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#174
  def initialize(fn); end

  # @api private
  # @return [Function]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#209
  def <<(other); end

  # @api private
  # @return [Function]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#203
  def >>(other); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#179
  def [](input, &block); end

  # @api private
  # @return [Integer]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#185
  def arity; end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#179
  def call(input, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#172
  def fn; end

  # @api private
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#194
  def to_ast; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#189
  def wrapper?; end

  class << self
    # Choose or build specialized invokation code for a callable
    #
    # @api private
    # @param fn [#call]
    # @raise [::ArgumentError]
    # @return [Function]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#142
    def [](fn); end

    # @api private
    # @return [Boolean]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#159
    def yields_block?(fn); end
  end
end

# Coercion via a method call on a known object
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#27
class Dry::Types::Constructor::Function::MethodCall < ::Dry::Types::Constructor::Function
  # @api private
  # @return [MethodCall] a new instance of MethodCall
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#113
  def initialize(fn); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#111
  def name; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#111
  def target; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#119
  def to_ast; end

  class << self
    # @api private
    # @return [MethodCall]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#106
    def [](fn, safe); end

    # Choose or build the base class
    #
    # @api private
    # @return [Function]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#33
    def call_class(method, public, safe); end
  end
end

# Coercion via a private method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#86
class Dry::Types::Constructor::Function::MethodCall::PrivateCall < ::Dry::Types::Constructor::Function::MethodCall
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#87
  def call(input, &block); end
end

# Coercion via an unsafe private method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#95
class Dry::Types::Constructor::Function::MethodCall::PrivateSafeCall < ::Dry::Types::Constructor::Function::MethodCall::PrivateCall
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#96
  def call(input, &block); end
end

# Coercion with a publicly accessible method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#54
class Dry::Types::Constructor::Function::MethodCall::PublicCall < ::Dry::Types::Constructor::Function::MethodCall
  class << self
    # Choose or build the interface
    #
    # @api private
    # @return [::Module]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#60
    def call_interface(method, safe); end
  end
end

# Wrapper for unsafe coercion functions
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#16
class Dry::Types::Constructor::Function::Safe < ::Dry::Types::Constructor::Function
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#17
  def call(input, &block); end
end

# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#125
class Dry::Types::Constructor::Function::Wrapper < ::Dry::Types::Constructor::Function
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#126
  def [](input, type, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#133
  def arity; end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#126
  def call(input, type, &block); end
end

# @api public
#
# source://dry-types//lib/dry/types/constructor/wrapper.rb#7
module Dry::Types::Constructor::Wrapper
  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#60
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def append(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#11
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#18
  def call_unsafe(input); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#133
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#77
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#60
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#29
  def try(input, &block); end

  private

  # Replace underlying type
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#88
  def __new__(type); end
end

# Internal container for the built-in types
#
# @api private
#
# source://dry-types//lib/dry/types/container.rb#10
class Dry::Types::Container
  include ::Dry::Container::Mixin::Initializer
  include ::Dry::Container::Mixin
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # source://dry-container/0.9.0/lib/dry/container/mixin.rb#76
  def config; end
end

# Common API for types
#
# @api public
#
# source://dry-types//lib/dry/types/decorator.rb#10
module Dry::Types::Decorator
  include ::Dry::Types::Options

  # @api public
  # @param type [Type]
  #
  # source://dry-types//lib/dry/types/decorator.rb#17
  def initialize(type, *_arg1, **_arg2); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#43
  def constrained?; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#36
  def default?; end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/decorator.rb#62
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/decorator.rb#29
  def try(input, &block); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/decorator.rb#14
  def type; end

  private

  # Replace underlying type
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/decorator.rb#102
  def __new__(type); end

  # @api private
  # @param response [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#73
  def decorate?(response); end

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param meth [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  #
  # source://dry-types//lib/dry/types/decorator.rb#84
  def method_missing(meth, *args, **_arg2, &block); end

  # @api public
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#53
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Default types are useful when a missing value should be replaced by a default one
#
# @api public
#
# source://dry-types//lib/dry/types/default.rb#11
class Dry::Types::Default
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param type [Type]
  # @param value [Object]
  # @return [Default] a new instance of Default
  #
  # source://dry-types//lib/dry/types/default.rb#56
  def initialize(type, value, **options); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  #
  # source://dry-types//lib/dry/types/default.rb#113
  def call_safe(input = T.unsafe(nil), &block); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  #
  # source://dry-types//lib/dry/types/default.rb#100
  def call_unsafe(input = T.unsafe(nil)); end

  # @api private
  # @return [false]
  #
  # source://dry-types//lib/dry/types/default.rb#124
  def callable?; end

  # Build a constrained type
  #
  # @api public
  # @param args [Array] see {Dry::Types::Builder#constrained}
  # @return [Default]
  #
  # source://dry-types//lib/dry/types/default.rb#68
  def constrained(*args); end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/default.rb#75
  def default?; end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#35
  def evaluate; end

  # @api public
  # @param input [Object]
  # @return [Result::Success]
  #
  # source://dry-types//lib/dry/types/default.rb#84
  def try(input); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/default.rb#91
  def valid?(value = T.unsafe(nil)); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#35
  def value; end

  class << self
    # @api private
    # @param value [Object, #call]
    # @return [Class] {Default} or {Default::Callable}
    #
    # source://dry-types//lib/dry/types/default.rb#44
    def [](value); end
  end
end

# @api private
#
# source://dry-types//lib/dry/types/default.rb#13
class Dry::Types::Default::Callable < ::Dry::Types::Default
  # @api private
  # @return [true]
  #
  # source://dry-types//lib/dry/types/default.rb#23
  def callable?; end

  # Evaluates given callable
  #
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#18
  def evaluate; end
end

# @api public
Dry::Types::Definition = Dry::Types::Nominal

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Enum types can be used to define an enum on top of an existing type
#
# @api public
#
# source://dry-types//lib/dry/types/enum.rb#11
class Dry::Types::Enum
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder

  # @api private
  # @option options
  # @param type [Type]
  # @param options [Hash]
  # @return [Enum] a new instance of Enum
  #
  # source://dry-types//lib/dry/types/enum.rb#31
  def initialize(type, **options); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#49
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#42
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/enum.rb#61
  def default(*_arg0); end

  # Check whether a value is in the enum
  #
  # @api public
  #
  # source://dry-types//lib/dry/types/type.rb#20
  def include?(input = T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#79
  def inspect; end

  # @api public
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/enum.rb#24
  def inverted_mapping; end

  # @api public
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/enum.rb#21
  def mapping; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/enum.rb#72
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#79
  def to_s; end

  # @api public
  # @see Dry::Types::Constrained#try
  #
  # source://dry-types//lib/dry/types/enum.rb#56
  def try(input); end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/enum.rb#18
  def values; end

  private

  # Maps a value
  #
  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#93
  def map_value(input); end
end

# Internal container for constructor functions used by the built-in types
#
# @api private
#
# source://dry-types//lib/dry/types/fn_container.rb#10
class Dry::Types::FnContainer
  class << self
    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#25
    def [](fn_name); end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#12
    def container; end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#17
    def register(function = T.unsafe(nil), &block); end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#34
    def register_name(function); end
  end
end

# Hash types can be used to define maps and schemas
#
# @api public
#
# source://dry-types//lib/dry/types/hash/constructor.rb#10
class Dry::Types::Hash < ::Dry::Types::Nominal
  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#79
  def constructor_type; end

  # Build a map type
  #
  # @api public
  # @param key_type [Type]
  # @param value_type [Type]
  # @return [Map]
  #
  # source://dry-types//lib/dry/types/hash.rb#42
  def map(key_type, value_type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#52
  def permissive(*_arg0); end

  # @api public
  # @overload schema
  # @overload schema
  #
  # source://dry-types//lib/dry/types/hash.rb#24
  def schema(keys_or_map, meta = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#52
  def strict(*_arg0); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#52
  def strict_with_defaults(*_arg0); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#52
  def symbolized(*_arg0); end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/hash.rb#97
  def to_ast(meta: T.unsafe(nil)); end

  # Whether the type transforms types of schemas created by {Dry::Types::Hash#schema}
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/hash.rb#88
  def transform_types?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#52
  def weak(*_arg0); end

  # Injects a type transformation function for building schemas
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [ArgumentError]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/hash.rb#69
  def with_type_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#104
  def build_keys(type_map); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#125
  def key_name(key); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#116
  def resolve_type(type); end
end

# @api public
#
# source://dry-types//lib/dry/types/hash/constructor.rb#12
class Dry::Types::Hash::Constructor < ::Dry::Types::Constructor
  # @api private
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#13
  def constructor_type; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#20
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#27
  def schema(*args); end
end

# @api public
#
# source://dry-types//lib/dry/types/hash.rb#11
Dry::Types::Hash::NOT_REQUIRED = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::IDENTITY = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://dry-types//lib/dry/types/inflector.rb#7
Dry::Types::Inflector = T.let(T.unsafe(nil), Dry::Inflector)

# Primitives with {Kernel} coercion methods
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#8
Dry::Types::KERNEL_COERCIBLE = T.let(T.unsafe(nil), Hash)

# Lax types rescue from type-related errors when constructors fail
#
# @api public
#
# source://dry-types//lib/dry/types/lax.rb#11
class Dry::Types::Lax
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#25
  def [](input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#25
  def call(input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#25
  def call_safe(input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#25
  def call_unsafe(input); end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/lax.rb#55
  def lax; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/lax.rb#48
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/lax.rb#41
  def try(input, &block); end

  private

  # @api private
  # @param response [Object, Dry::Types::Constructor]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/lax.rb#66
  def decorate?(response); end
end

# Primitives with coercions through by convention `to_*` methods
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#18
Dry::Types::METHOD_COERCIBLE = T.let(T.unsafe(nil), Hash)

# By convention methods to coerce {METHOD_COERCIBLE} primitives
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#23
Dry::Types::METHOD_COERCIBLE_METHODS = T.let(T.unsafe(nil), Hash)

# Homogeneous mapping. It describes a hash with unknown keys that match a certain type.
#
# @api public
# @example
#   type = Dry::Types['hash'].map(
#   Dry::Types['integer'].constrained(gteq: 1, lteq: 10),
#   Dry::Types['string']
#   )
#
#   type.(1 => 'right')
#   # => {1 => 'right'}
#
#   type.('1' => 'wrong')
#   # Dry::Types::MapError: "1" violates constraints (type?(Integer, "1") AND gteq?(1, "1") AND lteq?(10, "1") failed)
#
#   type.(11 => 'wrong')
#   # Dry::Types::MapError: 11 violates constraints (lteq?(10, 11) failed)
#
# source://dry-types//lib/dry/types/map.rb#23
class Dry::Types::Map < ::Dry::Types::Nominal
  # @api public
  # @return [Map] a new instance of Map
  #
  # source://dry-types//lib/dry/types/map.rb#24
  def initialize(_primitive, key_type: T.unsafe(nil), value_type: T.unsafe(nil), meta: T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/map.rb#65
  def call_safe(hash); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/map.rb#54
  def call_unsafe(hash); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/map.rb#96
  def constrained?; end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/map.rb#31
  def key_type; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/map.rb#45
  def name; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/map.rb#86
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param hash [Hash]
  # @return [Result]
  # @yield [result]
  #
  # source://dry-types//lib/dry/types/map.rb#74
  def try(hash); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/map.rb#38
  def value_type; end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/map.rb#103
  def coerce(input); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#77
class Dry::Types::MapError < ::Dry::Types::CoercionError; end

# Storage for meta-data
#
# @api public
#
# source://dry-types//lib/dry/types/meta.rb#8
module Dry::Types::Meta
  # @api public
  #
  # source://dry-types//lib/dry/types/meta.rb#9
  def initialize(*args, meta: T.unsafe(nil), **options); end

  # @api public
  # @overload meta
  # @overload meta
  #
  # source://dry-types//lib/dry/types/meta.rb#31
  def meta(data = T.unsafe(nil)); end

  # Resets meta
  #
  # @api public
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/meta.rb#46
  def pristine; end

  # @api public
  # @param options [Hash] new_options
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/meta.rb#19
  def with(**options); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#83
class Dry::Types::MissingKeyError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param key [String, Symbol]
  # @return [MissingKeyError] a new instance of MissingKeyError
  #
  # source://dry-types//lib/dry/types/errors.rb#87
  def initialize(key); end

  # @api public
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/errors.rb#84
  def key; end
end

# Export types registered in a container as module constants.
#
# @api public
# @example
#   module Types
#   include Dry::Types(:strict, :coercible, :nominal, default: :strict)
#   end
#
#   Types.constants
#   # => [:Class, :Strict, :Symbol, :Integer, :Float, :String, :Array, :Hash,
#   #     :Decimal, :Nil, :True, :False, :Bool, :Date, :Nominal, :DateTime, :Range,
#   #     :Coercible, :Time]
#
# source://dry-types//lib/dry/types/module.rb#20
class Dry::Types::Module < ::Module
  # @api public
  # @return [Module] a new instance of Module
  #
  # source://dry-types//lib/dry/types/module.rb#21
  def initialize(registry, *args, **kwargs); end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#69
  def registry_tree; end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#41
  def type_constants(*namespaces, default: T.unsafe(nil), **aliases); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#84
  def check_parameters(*namespaces, default: T.unsafe(nil), **aliases); end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#102
  def define_constants(constants, mod = T.unsafe(nil)); end
end

# Collection of multiple errors
#
# @api public
#
# source://dry-types//lib/dry/types/errors.rb#49
class Dry::Types::MultipleError < ::Dry::Types::CoercionError
  # @api public
  # @param errors [Array<CoercionError>]
  # @return [MultipleError] a new instance of MultipleError
  #
  # source://dry-types//lib/dry/types/errors.rb#53
  def initialize(errors); end

  # @api public
  # @return [Array<CoercionError>]
  #
  # source://dry-types//lib/dry/types/errors.rb#50
  def errors; end

  # @api public
  # @return string
  #
  # source://dry-types//lib/dry/types/errors.rb#58
  def message; end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/errors.rb#63
  def meta; end
end

# Primitives that are non-coercible
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#28
Dry::Types::NON_COERCIBLE = T.let(T.unsafe(nil), Hash)

# All built-in primitives except {NilClass}
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#46
Dry::Types::NON_NIL = T.let(T.unsafe(nil), Hash)

# Nominal types define a primitive class and do not apply any constructors or constraints
#
# Use these types for annotations and the base for building more complex types on top of them.
#
# @api public
#
# source://dry-types//lib/dry/types/nominal.rb#17
class Dry::Types::Nominal
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param primitive [Type, Class]
  # @param options [Hash]
  # @return [Nominal] a new instance of Nominal
  #
  # source://dry-types//lib/dry/types/nominal.rb#49
  def initialize(primitive, **options); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  #
  # source://dry-types//lib/dry/types/nominal.rb#97
  def call_safe(input); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  #
  # source://dry-types//lib/dry/types/nominal.rb#88
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/nominal.rb#146
  def coerce(input, &_block); end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#72
  def constrained?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#65
  def default?; end

  # @api public
  # @raise [ArgumentError]
  # @return [Result::Failure]
  #
  # source://dry-types//lib/dry/types/nominal.rb#128
  def failure(input, error); end

  # Return self. Nominal types are lax by definition
  #
  # @api public
  # @return [Nominal]
  #
  # source://dry-types//lib/dry/types/nominal.rb#188
  def lax; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/nominal.rb#58
  def name; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#79
  def optional?; end

  # @api public
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/nominal.rb#26
  def primitive; end

  # Checks whether value is of a #primitive class
  #
  # @api public
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/nominal.rb#141
  def primitive?(value); end

  # @api public
  # @return [Result::Success]
  #
  # source://dry-types//lib/dry/types/nominal.rb#119
  def success(input); end

  # Return AST representation of a type nominal
  #
  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/nominal.rb#179
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/nominal.rb#197
  def to_proc; end

  # @api public
  # @param input [Object]
  # @return [Result, Logic::Result] when a block is not provided
  # @return [nil] otherwise
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/nominal.rb#110
  def try(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/nominal.rb#157
  def try_coerce(input); end

  class << self
    # @api private
    # @param primitive [Class]
    # @return [Type]
    #
    # source://dry-types//lib/dry/types/nominal.rb#33
    def [](primitive); end
  end
end

# @api public
#
# source://dry-types//lib/dry/types/nominal.rb#43
Dry::Types::Nominal::ALWAYS = T.let(T.unsafe(nil), Proc)

# Common API for types with options
#
# @api private
#
# source://dry-types//lib/dry/types/options.rb#8
module Dry::Types::Options
  # @api private
  # @see Nominal#initialize
  #
  # source://dry-types//lib/dry/types/options.rb#15
  def initialize(*args, **options); end

  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/options.rb#10
  def options; end

  # @api private
  # @param new_options [Hash]
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/options.rb#25
  def with(**new_options); end
end

# @api public
#
# source://dry-types//lib/dry/types/printer.rb#313
Dry::Types::PRINTER = T.let(T.unsafe(nil), Dry::Types::Printer)

# @api private
#
# source://dry-types//lib/dry/types/printable.rb#6
module Dry::Types::Printable
  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/printable.rb#10
  def inspect; end

  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/printable.rb#10
  def to_s; end
end

# @api private
#
# source://dry-types//lib/dry/types/printer.rb#6
class Dry::Types::Printer
  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#27
  def call(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#33
  def visit(type, &block); end

  # @api private
  # @yield ["Any"]
  #
  # source://dry-types//lib/dry/types/printer.rb#46
  def visit_any(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#50
  def visit_array(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#56
  def visit_array_member(array); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#254
  def visit_callable(callable); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#77
  def visit_constrained(constrained); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#64
  def visit_constructor(constructor); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#209
  def visit_default(default); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#190
  def visit_enum(enum); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#235
  def visit_hash(hash); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#141
  def visit_key(key); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#229
  def visit_lax(lax); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#127
  def visit_map(map); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#223
  def visit_nominal(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#289
  def visit_options(options, meta = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#88
  def visit_schema(schema); end

  # source://dry-types//lib/dry/types/printer.rb#64
  def visit_struct_constructor(constructor); end

  # source://dry-struct/1.4.0/lib/dry/struct/printer.rb#12
  def visit_struct_sum(sum); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#151
  def visit_sum(sum); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#159
  def visit_sum_constructors(sum); end
end

# @api private
#
# source://dry-types//lib/dry/types/printer.rb#7
Dry::Types::Printer::MAPPING = T.let(T.unsafe(nil), Hash)

# Result class used by {Type#try}
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#10
class Dry::Types::Result
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param input [Object]
  # @return [Result] a new instance of Result
  #
  # source://dry-types//lib/dry/types/result.rb#19
  def initialize(input); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/result.rb#14
  def input; end
end

# Failure result
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#45
class Dry::Types::Result::Failure < ::Dry::Types::Result
  # @api private
  # @param input [Object]
  # @param error [#to_s]
  # @return [Failure] a new instance of Failure
  #
  # source://dry-types//lib/dry/types/result.rb#56
  def initialize(input, error); end

  # @api public
  # @return [#to_s]
  #
  # source://dry-types//lib/dry/types/result.rb#49
  def error; end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/result.rb#78
  def failure?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/result.rb#71
  def success?; end

  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/result.rb#64
  def to_s; end
end

# Success result
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#29
class Dry::Types::Result::Success < ::Dry::Types::Result
  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/result.rb#37
  def failure?; end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/result.rb#30
  def success?; end
end

# @api public
Dry::Types::Safe = Dry::Types::Lax

# The built-in Hash type can be defined in terms of keys and associated types
# its values can contain. Such definitions are named {Schema}s and defined
# as lists of {Key} types.
#
# {Schema} evaluates default values for keys missing in input hash
#
# {Schema} implements Enumerable using its keys as collection.
#
# @api public
# @see Dry::Types::Schema::Key
# @see Dry::Types::Default#evaluate
# @see Dry::Types::Default::Callable#evaluate
#
# source://dry-types//lib/dry/types/schema/key.rb#16
class Dry::Types::Schema < ::Dry::Types::Hash
  include ::Enumerable

  # @api private
  # @option options
  # @option options
  # @param _primitive [Class]
  # @param options [Hash]
  # @return [Schema] a new instance of Schema
  #
  # source://dry-types//lib/dry/types/schema.rb#43
  def initialize(_primitive, **options); end

  # @api public
  # @option options
  # @option options
  # @param hash [Hash]
  # @param options [Hash] a customizable set of options
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#82
  def apply(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#70
  def call_safe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#61
  def call_unsafe(hash, options = T.unsafe(nil)); end

  # Empty schema with the same options
  #
  # @api public
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#296
  def clear; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#268
  def constrained?; end

  # Iterate over each key type
  #
  # @api public
  # @return [Array<Dry::Types::Schema::Key>, Enumerator]
  #
  # source://dry-types//lib/dry/types/schema.rb#227
  def each(&block); end

  # Fetch key type by a key name
  #
  # Behaves as ::Hash#fetch
  #
  # @api public
  # @overload key
  # @overload key
  #
  # source://dry-types//lib/dry/types/schema.rb#257
  def key(name, fallback = T.unsafe(nil), &block); end

  # Whether the schema has the given key
  #
  # @api public
  # @param name [Symbol] Key name
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#238
  def key?(name); end

  # @api public
  # @return [Array[Dry::Types::Schema::Key]]
  #
  # source://dry-types//lib/dry/types/schema.rb#28
  def keys; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/schema.rb#275
  def lax; end

  # Merge given schema keys into current schema
  #
  # A new instance is returned.
  #
  # @api public
  # @param other [Schema] schema
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#287
  def merge(other); end

  # @api public
  # @return [Hash[Symbol, Dry::Types::Schema::Key]]
  #
  # source://dry-types//lib/dry/types/schema.rb#31
  def name_key_map; end

  # @api public
  # @overload schema
  # @overload schema
  #
  # source://dry-types//lib/dry/types/schema.rb#211
  def schema(keys_or_map); end

  # Make the schema intolerant to unknown keys
  #
  # @api public
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#170
  def strict(strict = T.unsafe(nil)); end

  # Whether the schema rejects unknown keys
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#161
  def strict?; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/schema.rb#147
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [#call]
  #
  # source://dry-types//lib/dry/types/schema.rb#34
  def transform_key; end

  # Whether the schema transforms input keys
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#196
  def transform_keys?; end

  # @api public
  # @param input [Hash] hash
  # @return [Logic::Result]
  # @return [Object] if coercion fails and a block is given
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/schema.rb#95
  def try(input); end

  # Inject a key transformation function
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [ArgumentError]
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#182
  def with_key_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  # @param keys [Array<Dry::Types::Schema::Keys>]
  # @return [Dry::Types::Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#307
  def merge_keys(*keys); end

  # @api private
  # @return [MissingKeyError]
  #
  # source://dry-types//lib/dry/types/schema.rb#403
  def missing_key(key); end

  # Try to add missing keys to the hash
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/schema.rb#371
  def resolve_missing_keys(hash, options); end

  # Validate and coerce a hash. Call a block and halt on any error
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/schema.rb#349
  def resolve_safe(hash, options = T.unsafe(nil), &block); end

  # Validate and coerce a hash. Raise an exception on any error
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/schema.rb#319
  def resolve_unsafe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash_keys [Array<Symbol>]
  # @return [UnknownKeysError]
  #
  # source://dry-types//lib/dry/types/schema.rb#395
  def unexpected_keys(hash_keys); end
end

# Proxy type for schema keys. Contains only key name and
# whether it's required or not. All other calls deletaged
# to the wrapped type.
#
# @api public
# @see Dry::Types::Schema
#
# source://dry-types//lib/dry/types/schema/key.rb#17
class Dry::Types::Schema::Key
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Key] a new instance of Key
  #
  # source://dry-types//lib/dry/types/schema/key.rb#29
  def initialize(type, name, required: T.unsafe(nil), **options); end

  # @api private
  #
  # source://dry-types//lib/dry/types/schema/key.rb#43
  def call_safe(input, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/schema/key.rb#48
  def call_unsafe(input); end

  # Turn key into a lax type. Lax types are not strict hence such keys are not required
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#102
  def lax; end

  # @api public
  # @see Dry::Types::Meta#meta
  #
  # source://dry-types//lib/dry/types/schema/key.rb#134
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#26
  def name; end

  # Make key not required
  #
  # @api public
  # @return [Dry::Types::Schema::Key]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#93
  def omittable; end

  # Make wrapped type optional
  #
  # @api public
  # @return [Key]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#111
  def optional; end

  # Control whether the key is required
  #
  # @api public
  # @overload required
  # @overload required
  #
  # source://dry-types//lib/dry/types/schema/key.rb#80
  def required(required = T.unsafe(nil)); end

  # Whether the key is required in schema input
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#64
  def required?; end

  # Dump to internal AST representation
  #
  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#120
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @see Dry::Types::Nominal#try
  #
  # source://dry-types//lib/dry/types/schema/key.rb#55
  def try(input, &block); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#150
  def decorate?(response); end
end

# @api public
#
# source://dry-types//lib/dry/types/schema.rb#22
Dry::Types::Schema::NO_TRANSFORM = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-types//lib/dry/types/schema.rb#23
Dry::Types::Schema::SYMBOLIZE_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#71
class Dry::Types::SchemaError < ::Dry::Types::CoercionError
  # @api public
  # @param key [String, Symbol]
  # @param value [Object]
  # @param result [String, #to_s]
  # @return [SchemaError] a new instance of SchemaError
  #
  # source://dry-types//lib/dry/types/errors.rb#72
  def initialize(key, value, result); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#79
class Dry::Types::SchemaKeyError < ::Dry::Types::CoercionError; end

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Self = T.let(T.unsafe(nil), Proc)

# Sum type
#
# @api public
#
# source://dry-types//lib/dry/types/sum.rb#12
class Dry::Types::Sum
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param left [Type]
  # @param right [Type]
  # @param options [Hash]
  # @return [Sum] a new instance of Sum
  #
  # source://dry-types//lib/dry/types/sum.rb#44
  def initialize(left, right, **options); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#92
  def call_safe(input, &block); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#83
  def call_unsafe(input); end

  # @api public
  # @param options [Hash]
  # @return [Constrained, Sum]
  # @see Builder#constrained
  #
  # source://dry-types//lib/dry/types/sum.rb#170
  def constrained(options); end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/sum.rb#67
  def constrained?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/sum.rb#60
  def default?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/sum.rb#123
  def failure(input, _error = T.unsafe(nil)); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/sum.rb#21
  def left; end

  # Manage metadata to the type. If the type is an optional, #meta delegates
  # to the right branch
  #
  # @api public
  # @see [Meta#meta]
  #
  # source://dry-types//lib/dry/types/sum.rb#146
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/sum.rb#53
  def name; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/sum.rb#74
  def optional?; end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/sum.rb#136
  def primitive?(value); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/sum.rb#24
  def right; end

  # @api private
  #
  # source://dry-types//lib/dry/types/sum.rb#112
  def success(input); end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/sum.rb#159
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/sum.rb#183
  def to_proc; end

  # @api public
  # @param input [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#99
  def try(input); end
end

# @api private
#
# source://dry-types//lib/dry/types/sum.rb#28
class Dry::Types::Sum::Constrained < ::Dry::Types::Sum
  # @api private
  # @return [true]
  #
  # source://dry-types//lib/dry/types/sum.rb#34
  def constrained?; end

  # @api private
  # @return [Dry::Logic::Operations::Or]
  #
  # source://dry-types//lib/dry/types/sum.rb#29
  def rule; end
end

# @api public
#
# source://dry-types//lib/dry/types.rb#35
Dry::Types::TYPE_SPEC_REGEX = T.let(T.unsafe(nil), Regexp)

# Common Type module denoting an object is a Type
#
# @api public
#
# source://dry-types//lib/dry/types/type.rb#10
module Dry::Types::Type
  extend ::Dry::Core::Deprecations::Interface

  # Whether a value is a valid member of the type
  # Anything can be coerced matches
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/type.rb#20
  def ===(input = T.unsafe(nil)); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  #
  # source://dry-types//lib/dry/types/type.rb#45
  def [](input = T.unsafe(nil), &block); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  #
  # source://dry-types//lib/dry/types/type.rb#45
  def call(input = T.unsafe(nil), &block); end

  # source://dry-core/0.7.1/lib/dry/core/deprecations.rb#168
  def safe(*args, &block); end

  # Whether a value is a valid member of the type
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/type.rb#20
  def valid?(input = T.unsafe(nil)); end
end

# source://dry-core/0.7.1/lib/dry/core/constants.rb#112
Dry::Types::Undefined = T.let(T.unsafe(nil), Object)

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#94
class Dry::Types::UnknownKeysError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param keys [<String, Symbol>]
  # @return [UnknownKeysError] a new instance of UnknownKeysError
  #
  # source://dry-types//lib/dry/types/errors.rb#98
  def initialize(keys); end

  # @api public
  # @return [Array<Symbol>]
  #
  # source://dry-types//lib/dry/types/errors.rb#95
  def keys; end
end

# @api public
#
# source://dry-types//lib/dry/types/version.rb#5
Dry::Types::VERSION = T.let(T.unsafe(nil), String)
