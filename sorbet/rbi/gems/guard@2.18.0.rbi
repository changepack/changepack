# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `guard` gem.
# Please instead update this file by running `bin/tapioca gem guard`.

module Guard
  extend ::Guard::Deprecated::Guard::ClassMethods
  extend ::Guard::Internals::Helpers

  class << self
    def async_queue_add(changes); end
    def init(cmdline_options); end
    def interactor; end
    def listener; end
    def queue; end
    def setup(cmdline_options = T.unsafe(nil)); end
    def state; end

    private

    def _evaluate(options); end
    def _guardfile_deprecated_check(modified); end
    def _listener_callback; end
    def _pluginless_guardfile?; end
    def _relative_pathnames(paths); end
    def _relevant_changes?(changes); end
  end
end

class Guard::Config < ::Nenv::Environment
  def initialize; end

  def silence_deprecations?; end
end

module Guard::Deprecated; end

module Guard::Deprecated::Dsl
  class << self
    def add_deprecated(dsl_klass); end
  end
end

module Guard::Deprecated::Dsl::ClassMethods
  def evaluate_guardfile(options = T.unsafe(nil)); end
end

Guard::Deprecated::Dsl::ClassMethods::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)
Guard::Deprecated::Dsl::MORE_INFO_ON_UPGRADING_TO_GUARD_2 = T.let(T.unsafe(nil), String)

module Guard::Deprecated::Evaluator
  def evaluate_guardfile; end
  def reevaluate_guardfile; end

  class << self
    def add_deprecated(klass); end
  end
end

Guard::Deprecated::Evaluator::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)
Guard::Deprecated::Evaluator::REEVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)

module Guard::Deprecated::Guard
  class << self
    def add_deprecated(klass); end
  end
end

module Guard::Deprecated::Guard::ClassMethods
  def add_group(name, options = T.unsafe(nil)); end
  def add_guard(*args); end
  def add_plugin(name, options = T.unsafe(nil)); end
  def evaluate_guardfile; end
  def evaluator; end
  def get_guard_class(name, fail_gracefully = T.unsafe(nil)); end
  def group(filter); end
  def groups(filter); end
  def guard_gem_names; end
  def guards(filter = T.unsafe(nil)); end
  def listener=(_); end
  def locate_guard(name); end
  def lock; end
  def options; end
  def plugin(filter); end
  def plugins(filter); end
  def reset_evaluator(_options); end
  def runner; end
  def running; end
  def scope; end
  def scope=(scope); end
end

Guard::Deprecated::Guard::ClassMethods::ADD_GROUP = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::ADD_GUARD = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::ADD_PLUGIN = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::EVALUATOR = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::GET_GUARD_CLASS = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::GROUP = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::GROUPS = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::GUARDS = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::GUARD_GEM_NAMES = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::LISTENER_ASSIGN = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::LOCATE_GUARD = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::LOCK = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::MORE_INFO_ON_UPGRADING_TO_GUARD_2 = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::OPTIONS = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::PLUGIN = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::PLUGINS = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::RESET_EVALUATOR = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::RUNNER = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::RUNNING = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::SCOPE = T.let(T.unsafe(nil), String)
Guard::Deprecated::Guard::ClassMethods::SCOPE_ASSIGN = T.let(T.unsafe(nil), String)

module Guard::Deprecated::Watcher
  class << self
    def add_deprecated(klass); end
  end
end

module Guard::Deprecated::Watcher::ClassMethods
  def match_guardfile?(files); end
end

Guard::Deprecated::Watcher::ClassMethods::MATCH_GUARDFILE = T.let(T.unsafe(nil), String)

class Guard::Dsl
  extend ::Guard::Deprecated::Dsl::ClassMethods

  def callback(*args, &block); end
  def clearing(on); end
  def directories(directories); end
  def evaluate(contents, filename, lineno); end
  def filter(*regexps); end
  def filter!(*regexps); end
  def group(*args); end
  def guard(name, options = T.unsafe(nil)); end
  def ignore(*regexps); end
  def ignore!(*regexps); end
  def interactor(options); end
  def logger(options); end
  def notification(notifier, opts = T.unsafe(nil)); end
  def scope(scope = T.unsafe(nil)); end
  def watch(pattern, &action); end

  private

  def _cleanup_backtrace(backtrace); end
end

class Guard::Dsl::Error < ::RuntimeError; end
Guard::Dsl::WARN_INVALID_LOG_LEVEL = T.let(T.unsafe(nil), String)
Guard::Dsl::WARN_INVALID_LOG_OPTIONS = T.let(T.unsafe(nil), String)

class Guard::DslReader < ::Guard::Dsl
  def initialize; end

  def callback(*_args, &_block); end
  def clearing(_on); end
  def directories(_directories); end
  def group(*_args); end
  def guard(name, _options = T.unsafe(nil)); end
  def ignore(*_regexps); end
  def ignore!(*_regexps); end
  def interactor(_options); end
  def logger(_options); end
  def notification(_notifier, _opts = T.unsafe(nil)); end
  def plugin_names; end
  def scope(_scope = T.unsafe(nil)); end
  def watch(_pattern, &_action); end
end

class Guard::Group
  def initialize(name, options = T.unsafe(nil)); end

  def name; end
  def name=(_arg0); end
  def options; end
  def options=(_arg0); end
  def title; end
  def to_s; end
end

module Guard::Guardfile; end

class Guard::Guardfile::Evaluator
  include ::Guard::Deprecated::Evaluator

  def initialize(opts = T.unsafe(nil)); end

  def custom?; end
  def evaluate; end
  def guardfile_contents; end
  def guardfile_include?(plugin_name); end
  def guardfile_path; end
  def guardfile_source; end
  def inline?; end
  def options; end
  def path; end

  private

  def _fetch_guardfile_contents; end
  def _from_deprecated(opts); end
  def _guardfile_contents; end
  def _guardfile_contents_usable?; end
  def _guardfile_contents_without_user_config; end
  def _instance_eval_guardfile(contents); end
  def _read(path); end
  def _use_default!; end
  def _use_inline; end
  def _use_provided; end
end

Guard::Guardfile::Evaluator::DEFAULT_GUARDFILES = T.let(T.unsafe(nil), Array)
Guard::Guardfile::Evaluator::ERROR_NO_GUARDFILE = T.let(T.unsafe(nil), String)
Guard::Guardfile::Evaluator::ERROR_NO_PLUGINS = T.let(T.unsafe(nil), String)
class Guard::Guardfile::Evaluator::Error < ::RuntimeError; end
class Guard::Guardfile::Evaluator::NoCustomGuardfile < ::Guard::Guardfile::Evaluator::Error; end
class Guard::Guardfile::Evaluator::NoGuardfileError < ::Guard::Guardfile::Evaluator::Error; end
class Guard::Guardfile::Evaluator::NoPluginsError < ::Guard::Guardfile::Evaluator::Error; end

class Guard::Interactor
  extend ::Forwardable

  def initialize(no_interaction = T.unsafe(nil)); end

  def background(*args, **_arg1, &block); end
  def foreground(*args, **_arg1, &block); end
  def handle_interrupt(*args, **_arg1, &block); end
  def interactive?; end

  private

  def idle_job; end

  class << self
    def enabled; end
    def enabled=(_arg0); end
    def enabled?; end
    def options; end
    def options=(_arg0); end
  end
end

module Guard::Internals; end

class Guard::Internals::Debugging
  class << self
    def start; end
    def stop; end

    private

    def _notify(*args); end
    def _reset; end
    def _trace(mod, meth, &block); end
    def _untrace(mod, meth); end
  end
end

class Guard::Internals::Groups
  def initialize; end

  def add(name, options = T.unsafe(nil)); end
  def all(filter = T.unsafe(nil)); end

  private

  def matcher_for(filter); end
end

Guard::Internals::Groups::DEFAULT_GROUPS = T.let(T.unsafe(nil), Array)

module Guard::Internals::Helpers
  def _relative_pathname(path); end
end

class Guard::Internals::Plugins
  def initialize; end

  def add(name, options); end
  def all(filter = T.unsafe(nil)); end
  def remove(plugin); end

  private

  def matcher_for(filter); end
end

class Guard::Internals::Queue
  def initialize(commander); end

  def <<(changes); end
  def pending?; end
  def process; end

  private

  def _run_actions(actions); end
end

class Guard::Internals::Scope
  def initialize; end

  def from_interactor(scope); end
  def grouped_plugins(scope = T.unsafe(nil)); end
  def titles(scope = T.unsafe(nil)); end
  def to_hash; end

  private

  def _find_non_empty_scope(type, local_scope); end
  def _groups; end
  def _hashify_scope(type); end
  def _instantiate(meth, obj); end
  def _plugins; end
  def _scope_names(new_scope, name); end
end

class Guard::Internals::Session
  def initialize(new_options); end

  def clear?; end
  def clearing(on); end
  def clearing?; end
  def cmdline_groups; end
  def cmdline_plugins; end
  def convert_scope(entries); end
  def debug?; end
  def evaluator_options; end
  def groups; end
  def guardfile_group_scope; end
  def guardfile_ignore; end
  def guardfile_ignore=(ignores); end
  def guardfile_ignore_bang; end
  def guardfile_ignore_bang=(_arg0); end
  def guardfile_notification=(config); end
  def guardfile_plugin_scope; end
  def guardfile_scope(scope); end
  def interactor_name; end
  def listener_args; end
  def notify_options; end
  def plugins; end
  def watchdirs; end
  def watchdirs=(dirs); end
end

Guard::Internals::Session::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Guard::Internals::State
  def initialize(cmdline_opts); end

  def scope; end
  def session; end
end

module Guard::Internals::Tracing
  class << self
    def trace(mod, meth); end
    def untrace(mod, meth); end
  end
end

module Guard::Internals::Traps
  class << self
    def handle(signal, &block); end
  end
end

class Guard::Notifier
  class << self
    def connect(options = T.unsafe(nil)); end
    def detected; end
    def disconnect; end
    def notify(message, options = T.unsafe(nil)); end
    def supported; end
    def toggle; end
    def turn_on; end
  end
end

Guard::Notifier::DEPRECATED_IMPLICIT_CONNECT = T.let(T.unsafe(nil), String)

class Guard::Options < ::Thor::CoreExt::HashWithIndifferentAccess
  def initialize(opts = T.unsafe(nil), default_opts = T.unsafe(nil)); end

  def fetch(name); end
end

class Guard::Plugin
  def initialize(options = T.unsafe(nil)); end

  def callbacks; end
  def callbacks=(_arg0); end
  def group; end
  def group=(_arg0); end
  def hook(event, *args); end
  def name; end
  def options; end
  def options=(_arg0); end
  def title; end
  def to_s; end
  def watchers; end
  def watchers=(_arg0); end

  private

  def _register_callbacks; end

  class << self
    def add_callback(listener, guard_plugin, events); end
    def callbacks; end
    def non_namespaced_classname; end
    def non_namespaced_name; end
    def notify(guard_plugin, event, *args); end
    def reset_callbacks!; end
    def template(plugin_location); end
  end
end

Guard::Plugin::TEMPLATE_FORMAT = T.let(T.unsafe(nil), String)

class Guard::PluginUtil
  def initialize(name); end

  def add_to_guardfile; end
  def initialize_plugin(options); end
  def name; end
  def name=(_arg0); end
  def plugin_class(options = T.unsafe(nil)); end
  def plugin_location; end

  private

  def _constant_name; end
  def _full_gem_path(name); end
  def _plugin_constant; end

  class << self
    def _gem_valid?(gem); end
    def plugin_names; end
  end
end

Guard::PluginUtil::ERROR_NO_GUARD_OR_CLASS = T.let(T.unsafe(nil), String)
Guard::PluginUtil::INFO_ADDED_GUARD_TO_GUARDFILE = T.let(T.unsafe(nil), String)

class Guard::Runner
  def _supervise(plugin, task, *args); end
  def run(task, scope_hash = T.unsafe(nil)); end
  def run_on_changes(modified, added, removed); end

  private

  def _run_group_plugins(plugins); end

  class << self
    def stopping_symbol_for(guard); end
  end
end

Guard::Runner::ADDITION_TASKS = T.let(T.unsafe(nil), Array)
Guard::Runner::MODIFICATION_TASKS = T.let(T.unsafe(nil), Array)
Guard::Runner::PLUGIN_FAILED = T.let(T.unsafe(nil), String)
Guard::Runner::REMOVAL_TASKS = T.let(T.unsafe(nil), Array)

class Guard::Terminal
  class << self
    def clear; end
  end
end

module Guard::UI
  include ::Guard::UI::Colors

  class << self
    def action_with_scopes(action, scope); end
    def clear(opts = T.unsafe(nil)); end
    def clearable; end
    def debug(message, options = T.unsafe(nil)); end
    def deprecation(message, options = T.unsafe(nil)); end
    def error(message, options = T.unsafe(nil)); end
    def info(message, options = T.unsafe(nil)); end
    def level=(new_level); end
    def logger; end
    def options; end
    def options=(options); end
    def reset_and_clear; end
    def reset_line; end
    def reset_logger; end
    def warning(message, options = T.unsafe(nil)); end

    private

    def _calling_plugin_name; end
    def _filter(plugin); end
    def _filtered_logger_message(message, method, color_name, options = T.unsafe(nil)); end
    def color(text, *color_options); end
    def color_enabled?; end
  end
end

module Guard::UI::Colors; end
Guard::UI::Colors::ANSI_ESCAPE_BGBLACK = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BGBLUE = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BGCYAN = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BGGREEN = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BGMAGENTA = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BGRED = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BGWHITE = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BGYELLOW = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BLACK = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BLUE = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_BRIGHT = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_CYAN = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_GREEN = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_MAGENTA = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_RED = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_WHITE = T.let(T.unsafe(nil), String)
Guard::UI::Colors::ANSI_ESCAPE_YELLOW = T.let(T.unsafe(nil), String)

class Guard::UI::Config < ::Guard::Options
  def initialize(options = T.unsafe(nil)); end

  def [](name); end
  def device; end
  def except; end
  def logger_config; end
  def only; end
  def with_progname(name); end
end

Guard::UI::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)
Guard::UI::Config::DEPRECATED_OPTS = T.let(T.unsafe(nil), Array)
class Guard::UI::Logger; end

class Guard::UI::Logger::Config < ::Guard::Options
  def initialize(options = T.unsafe(nil)); end

  def level=(value); end
end

Guard::UI::Logger::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Guard::Watcher
  extend ::Guard::Deprecated::Watcher::ClassMethods

  def initialize(pattern, action = T.unsafe(nil)); end

  def ==(other); end
  def action; end
  def action=(_arg0); end
  def call_action(matches); end
  def match(string_or_pathname); end
  def pattern; end
  def pattern=(_arg0); end

  class << self
    def match_files(guard, files); end
  end
end

class Guard::Watcher::Pattern
  class << self
    def create(pattern); end
  end
end

class Guard::Watcher::Pattern::DeprecatedRegexp
  def initialize(pattern); end

  def deprecated?; end

  class << self
    def convert(pattern); end
    def show_deprecation(pattern); end
  end
end

class Guard::Watcher::Pattern::MatchResult
  def initialize(match_result, original_value); end

  def [](index); end
end

class Guard::Watcher::Pattern::Matcher
  def initialize(obj); end

  def ==(other); end
  def match(string_or_pathname); end
  def matcher; end

  private

  def normalized(string_or_pathname); end
end

class Guard::Watcher::Pattern::PathnamePath < ::Guard::Watcher::Pattern::SimplePath
  protected

  def normalize(string_or_pathname); end
end

class Guard::Watcher::Pattern::SimplePath
  def initialize(string_or_pathname); end

  def match(string_or_pathname); end

  protected

  def normalize(string_or_pathname); end
end
