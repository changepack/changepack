# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `action_policy` gem.
# Please instead update this file by running `bin/tapioca gem action_policy`.

# ActionPolicy is an authorization framework for Ruby/Rails applications.
#
# It provides a way to write access policies and helpers to check these policies
# in your application.
#
# source://action_policy//lib/action_policy.rb#12
module ActionPolicy
  class << self
    # Returns the value of attribute cache_store.
    #
    # source://action_policy//lib/action_policy.rb#35
    def cache_store; end

    # Sets the attribute cache_store
    #
    # @param value the value to set the attribute cache_store to.
    #
    # source://action_policy//lib/action_policy.rb#35
    def cache_store=(_arg0); end

    # Returns the value of attribute enforce_predicate_rules_naming.
    #
    # source://action_policy//lib/action_policy.rb#37
    def enforce_predicate_rules_naming; end

    # Sets the attribute enforce_predicate_rules_naming
    #
    # @param value the value to set the attribute enforce_predicate_rules_naming to.
    #
    # source://action_policy//lib/action_policy.rb#37
    def enforce_predicate_rules_naming=(_arg0); end

    # Find a policy class for a target
    #
    # source://action_policy//lib/action_policy.rb#40
    def lookup(target, allow_nil: T.unsafe(nil), default: T.unsafe(nil), **options); end
  end
end

# source://action_policy//lib/action_policy/policy/authorization.rb#4
class ActionPolicy::AuthorizationContextMissing < ::ActionPolicy::Error
  # @return [AuthorizationContextMissing] a new instance of AuthorizationContextMissing
  #
  # source://action_policy//lib/action_policy/policy/authorization.rb#9
  def initialize(id); end

  # Returns the value of attribute message.
  #
  # source://action_policy//lib/action_policy/policy/authorization.rb#7
  def message; end
end

# source://action_policy//lib/action_policy/policy/authorization.rb#5
ActionPolicy::AuthorizationContextMissing::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# The main purpose of this module is to extact authorize actions
# from everything else to make it easily testable.
#
# source://action_policy//lib/action_policy/authorizer.rb#19
module ActionPolicy::Authorizer
  class << self
    # source://action_policy//lib/action_policy/authorizer.rb#27
    def authorize(policy, rule); end

    # Performs authorization, raises an exception when check failed.
    #
    # source://action_policy//lib/action_policy/authorizer.rb#22
    def call(policy, rule); end

    # Applies scope to the target
    #
    # source://action_policy//lib/action_policy/authorizer.rb#32
    def scopify(target, policy, **options); end
  end
end

# Base class for application policies.
#
# source://action_policy//lib/action_policy/base.rb#5
class ActionPolicy::Base
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Policy::Core
  include ::ActionPolicy::Policy::Authorization
  include ::ActionPolicy::Policy::PreCheck
  include ::ActionPolicy::Policy::Reasons
  include ::ActionPolicy::Policy::Aliases
  include ::ActionPolicy::Behaviours::Scoping
  include ::ActionPolicy::Policy::Scoping
  include ::ActionPolicy::Policy::Cache
  include ::ActionPolicy::Policy::CachedApply
  include ::ActionPolicy::Policy::Defaults
  extend ::ActionPolicy::Policy::Core::ClassMethods
  extend ::ActionPolicy::Policy::Authorization::ClassMethods
  extend ::ActionPolicy::Policy::PreCheck::ClassMethods
  extend ::ActionPolicy::Policy::Aliases::ClassMethods
  extend ::ActionPolicy::Policy::Scoping::ClassMethods
  extend ::ActionPolicy::Policy::Cache::ClassMethods

  # source://action_policy//lib/action_policy/policy/authorization.rb#72
  def user; end
end

# source://action_policy//lib/action_policy/base.rb#0
class ActionPolicy::Base::APR < ::ActionPolicy::Policy::ExecutionResult
  include ::ActionPolicy::Policy::ResultFailureReasons
end

# Provides `authorize!` and `allowed_to?` methods and
# `authorize` class method to define authorization context.
#
# Could be included anywhere to perform authorization.
#
# source://action_policy//lib/action_policy/behaviour.rb#16
module ActionPolicy::Behaviour
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Behaviours::Scoping

  mixes_in_class_methods ::ActionPolicy::Behaviour::ClassMethods

  # Returns the authorization result object after applying a specified rule to a record.
  #
  # source://action_policy//lib/action_policy/behaviour.rb#53
  def allowance_to(rule, record = T.unsafe(nil), **options); end

  # Checks that an activity is allowed for the current context (e.g. user).
  #
  # Returns true of false.
  #
  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/behaviour.rb#46
  def allowed_to?(rule, record = T.unsafe(nil), **options); end

  # source://action_policy//lib/action_policy/behaviour.rb#60
  def authorization_context; end

  # Check that rule is defined for policy,
  # otherwise fallback to :manage? rule.
  #
  # source://action_policy//lib/action_policy/behaviour.rb#72
  def authorization_rule_for(policy, rule); end

  # Authorize action against a policy.
  #
  # Policy is inferred from record
  # (unless explicitly specified through `with` option).
  #
  # Raises `ActionPolicy::Unauthorized` if check failed.
  #
  # source://action_policy//lib/action_policy/behaviour.rb#37
  def authorize!(record = T.unsafe(nil), to:, **options); end

  # source://action_policy//lib/action_policy/behaviour.rb#76
  def lookup_authorization_policy(record, **options); end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/behaviour.rb#20
    def included(base); end
  end
end

# source://action_policy//lib/action_policy/behaviour.rb#83
module ActionPolicy::Behaviour::ClassMethods
  # source://action_policy//lib/action_policy/behaviour.rb#102
  def authorization_targets; end

  # Configure authorization context.
  #
  # For example:
  #
  #   class ApplicationController < ActionController::Base
  #     # Pass the value of `current_user` to authorization as `user`
  #     authorize :user, through: :current_user
  #   end
  #
  #   # Assuming that in your ApplicationPolicy
  #   class ApplicationPolicy < ActionPolicy::Base
  #     authorize :user
  #   end
  #
  # source://action_policy//lib/action_policy/behaviour.rb#97
  def authorize(key, through: T.unsafe(nil)); end
end

# source://action_policy//lib/action_policy/behaviours/policy_for.rb#4
module ActionPolicy::Behaviours; end

# Per-instance memoization for policies.
#
# Used by `policy_for` to re-use policy object for records.
#
# Example:
#
#   include ActionPolicy::Behaviour
#   include ActionPolicy::Memoized
#
#   record = User.first
#   policy = policy_for(record)
#   policy2 = policy_for(record)
#
#   policy.equal?(policy) #=> true
#
#   policy.equal?(policy_for(record, with: CustomPolicy)) #=> false
#
# source://action_policy//lib/action_policy/behaviours/memoized.rb#21
module ActionPolicy::Behaviours::Memoized
  # source://action_policy//lib/action_policy/behaviours/memoized.rb#47
  def __policies_cache__; end

  # source://action_policy//lib/action_policy/behaviours/memoized.rb#36
  def __policy_memoize__(record, **options); end

  class << self
    # source://action_policy//lib/action_policy/behaviours/memoized.rb#23
    def included(base); end

    # source://action_policy//lib/action_policy/behaviours/memoized.rb#23
    def prepended(base); end
  end
end

# source://action_policy//lib/action_policy/behaviours/memoized.rb#30
module ActionPolicy::Behaviours::Memoized::InstanceMethods
  # source://action_policy//lib/action_policy/behaviours/memoized.rb#31
  def policy_for(record:, **opts); end
end

# Adds an ability to lookup policies from current _context_ (namespace):
#
#   module Admin
#     class UsersController < ApplictionController
#       def index
#         # uses Admin::UserPolicy if any, otherwise fallbacks to UserPolicy
#         authorize!
#       end
#     end
#   end
#
# Modules nesting is also supported:
#
#   module Admin
#     module Client
#       class UsersController < ApplictionController
#         def index
#           # lookup for Admin::Client::UserPolicy -> Admin::UserPolicy -> UserPolicy
#           authorize!
#         end
#       end
#     end
#   end
#
# NOTE: in order to support namespaced lookup for non-inferrable resources,
# you should specify `policy_name` at a class level
# (instead of `policy_class`, which doesn't take into account namespaces):
#
#  class Guest < User
#     def self.policy_name
#       "UserPolicy"
#     end
#  end
#
# NOTE: by default, we use class's name as a policy name; so, for namespaced
# resources the namespace part is also included:
#
#  class Admin
#    class User
#    end
#  end
#
#  # search for Admin::UserPolicy, but not for UserPolicy
#  authorize! Admin::User.new
#
# You can access the current authorization namespace through `authorization_namespace` method.
#
# You can also define your own namespacing logic by overriding `authorization_namespace`:
#
#   def authorization_namespace
#     return ::Admin if current_user.admin?
#     return ::Staff if current_user.staff?
#     # fallback to current namespace
#     super
#   end
#
# source://action_policy//lib/action_policy/behaviours/namespaced.rb#60
module ActionPolicy::Behaviours::Namespaced
  class << self
    # source://action_policy//lib/action_policy/behaviours/namespaced.rb#65
    def included(base); end

    # source://action_policy//lib/action_policy/behaviours/namespaced.rb#65
    def prepended(base); end
  end
end

# source://action_policy//lib/action_policy/behaviours/namespaced.rb#72
module ActionPolicy::Behaviours::Namespaced::InstanceMethods
  # source://action_policy//lib/action_policy/behaviours/namespaced.rb#73
  def authorization_namespace; end
end

# Adds `policy_for` method
#
# source://action_policy//lib/action_policy/behaviours/policy_for.rb#6
module ActionPolicy::Behaviours::PolicyFor
  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#21
  def authorization_context; end

  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#25
  def authorization_namespace; end

  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#33
  def authorization_strict_namespace; end

  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#29
  def default_authorization_policy_class; end

  # Override this method to provide implicit authorization target
  # that would be used in case `record` is not specified in
  # `authorize!` and `allowed_to?` call.
  #
  # It is also used to infer a policy for scoping (in `authorized_scope` method).
  #
  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#42
  def implicit_authorization_target; end

  # Return implicit authorization target or raises an exception if it's nil
  #
  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#47
  def implicit_authorization_target!; end

  # Returns policy instance for the record.
  #
  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#11
  def policy_for(record:, with: T.unsafe(nil), namespace: T.unsafe(nil), context: T.unsafe(nil), allow_nil: T.unsafe(nil), default: T.unsafe(nil), strict_namespace: T.unsafe(nil)); end

  # source://action_policy//lib/action_policy/behaviours/policy_for.rb#60
  def policy_for_cache_key(record:, with: T.unsafe(nil), namespace: T.unsafe(nil), context: T.unsafe(nil), **_arg4); end
end

# Adds `authorized_scop` method to behaviour
#
# source://action_policy//lib/action_policy/behaviours/scoping.rb#6
module ActionPolicy::Behaviours::Scoping
  # Infer scope type for target if none provided.
  # Raises an exception if type couldn't be inferred.
  #
  # source://action_policy//lib/action_policy/behaviours/scoping.rb#30
  def authorization_scope_type_for(policy, target); end

  # Apply scope to the target of the specified type.
  #
  # NOTE: policy lookup consists of the following steps:
  #   - first, check whether `with` option is present
  #   - secondly, try to infer policy class from `target` (non-raising lookup)
  #   - use `implicit_authorization_target` if none of the above works.
  # For backward compatibility
  #
  # source://action_policy//lib/action_policy/behaviours/scoping.rb#13
  def authorized(target, type: T.unsafe(nil), as: T.unsafe(nil), scope_options: T.unsafe(nil), **options); end

  # Apply scope to the target of the specified type.
  #
  # NOTE: policy lookup consists of the following steps:
  #   - first, check whether `with` option is present
  #   - secondly, try to infer policy class from `target` (non-raising lookup)
  #   - use `implicit_authorization_target` if none of the above works.
  #
  # source://action_policy//lib/action_policy/behaviours/scoping.rb#13
  def authorized_scope(target, type: T.unsafe(nil), as: T.unsafe(nil), scope_options: T.unsafe(nil), **options); end
end

# Per-thread memoization for policies.
#
# Used by `policy_for` to re-use policy object for records.
#
# NOTE: don't forget to clear thread cache with ActionPolicy::PerThreadCache.clear_all
#
# source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#37
module ActionPolicy::Behaviours::ThreadMemoized
  # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#52
  def __policy_thread_memoize__(record, **options); end

  class << self
    # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#39
    def included(base); end

    # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#39
    def prepended(base); end
  end
end

# source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#46
module ActionPolicy::Behaviours::ThreadMemoized::InstanceMethods
  # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#47
  def policy_for(record:, **opts); end
end

# By default cache namespace (or prefix) contains major and minor version of the gem
#
# source://action_policy//lib/action_policy/policy/cache.rb#9
ActionPolicy::CACHE_NAMESPACE = T.let(T.unsafe(nil), String)

# Channel concern.
# Add `authorize!` and `allowed_to?` methods.
#
# source://action_policy//lib/action_policy/rails/channel.rb#9
module ActionPolicy::Channel
  include ::ActionPolicy::Behaviours::Namespaced::InstanceMethods
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Behaviours::Scoping
  include ::ActionPolicy::Behaviour
  include ::ActionPolicy::Behaviours::Namespaced
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionPolicy::Channel::ClassMethods
end

# source://action_policy//lib/action_policy/rails/channel.rb#0
module ActionPolicy::Channel::ClassMethods
  include ::ActionPolicy::Behaviour::ClassMethods
end

# Controller concern.
# Add `authorize!` and `allowed_to?` methods,
# provide `verify_authorized` hook.
#
# source://action_policy//lib/action_policy/rails/controller.rb#17
module ActionPolicy::Controller
  include ::ActionPolicy::Behaviours::ThreadMemoized::InstanceMethods
  include ::ActionPolicy::Behaviours::Memoized::InstanceMethods
  include ::ActionPolicy::Behaviours::Namespaced::InstanceMethods
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Behaviours::Scoping
  include ::ActionPolicy::Behaviour
  include ::ActionPolicy::Behaviours::ThreadMemoized
  include ::ActionPolicy::Behaviours::Memoized
  include ::ActionPolicy::Behaviours::Namespaced
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionPolicy::Controller::ClassMethods

  # Authorize action against a policy.
  #
  # Policy is inferred from record
  # (unless explicitly specified through `with` option).
  #
  # If action is not provided, it's inferred from `action_name`.
  #
  # If record is not provided, tries to infer the resource class
  # from controller name (i.e. `controller_name.classify.safe_constantize`).
  #
  # Raises `ActionPolicy::Unauthorized` if check failed.
  #
  # source://action_policy//lib/action_policy/rails/controller.rb#48
  def authorize!(record = T.unsafe(nil), to: T.unsafe(nil), **options); end

  # source://action_policy//lib/action_policy/rails/controller.rb#67
  def authorize_count; end

  # Tries to infer the resource class from controller name
  # (i.e. `controller_name.classify.safe_constantize`).
  #
  # source://action_policy//lib/action_policy/rails/controller.rb#58
  def implicit_authorization_target; end

  # source://action_policy//lib/action_policy/rails/controller.rb#71
  def skip_verify_authorized!; end

  # source://action_policy//lib/action_policy/rails/controller.rb#62
  def verify_authorized; end
end

# source://action_policy//lib/action_policy/rails/controller.rb#0
module ActionPolicy::Controller::ClassMethods
  include ::ActionPolicy::Behaviour::ClassMethods

  # source://action_policy//lib/action_policy/rails/controller.rb#83
  def skip_verify_authorized(**options); end

  # source://action_policy//lib/action_policy/rails/controller.rb#78
  def verify_authorized(**options); end
end

# source://action_policy//lib/action_policy.rb#13
class ActionPolicy::Error < ::StandardError; end

# source://action_policy//lib/action_policy/ext/policy_cache_key.rb#4
module ActionPolicy::Ext; end

# Add Module#namespace method
#
# source://action_policy//lib/action_policy/ext/module_namespace.rb#6
module ActionPolicy::Ext::ModuleNamespace; end

# source://action_policy//lib/action_policy/ext/module_namespace.rb#12
module ActionPolicy::Ext::ModuleNamespace::Ext
  # source://action_policy//lib/action_policy/ext/module_namespace.rb#13
  def namespace; end
end

# Adds #_policy_cache_key method to Object,
# which just call #policy_cache_key or #cache_key
# or #object_id (if `use_object_id` parameter is set to true).
#
# For other core classes returns string representation.
#
# Raises ArgumentError otherwise.
#
# source://action_policy//lib/action_policy/ext/policy_cache_key.rb#12
module ActionPolicy::Ext::PolicyCacheKey; end

# source://action_policy//lib/action_policy/ext/policy_cache_key.rb#13
module ActionPolicy::Ext::PolicyCacheKey::ObjectExt
  # @raise [ArgumentError]
  #
  # source://action_policy//lib/action_policy/ext/policy_cache_key.rb#14
  def _policy_cache_key(use_object_id: T.unsafe(nil)); end
end

# Add `camelize` to Symbol
#
# source://action_policy//lib/action_policy/ext/symbol_camelize.rb#6
module ActionPolicy::Ext::SymbolCamelize; end

# source://action_policy//lib/action_policy/i18n.rb#4
module ActionPolicy::I18n
  class << self
    # source://action_policy//lib/action_policy/i18n.rb#8
    def full_message(policy_class, rule, details = T.unsafe(nil)); end

    private

    # source://action_policy//lib/action_policy/i18n.rb#23
    def candidates_for(policy_class, rule); end
  end
end

# source://action_policy//lib/action_policy/i18n.rb#5
ActionPolicy::I18n::DEFAULT_UNAUTHORIZED_MESSAGE = T.let(T.unsafe(nil), String)

# LookupChain contains _resolvers_ to determine a policy
# for a record (with additional options).
#
# You can modify the `LookupChain.chain` (for example, to add
# custom resolvers).
#
# source://action_policy//lib/action_policy/lookup_chain.rb#9
module ActionPolicy::LookupChain
  class << self
    # source://action_policy//lib/action_policy/lookup_chain.rb#57
    def call(record, **opts); end

    # Returns the value of attribute chain.
    #
    # source://action_policy//lib/action_policy/lookup_chain.rb#53
    def chain; end

    # Sets the attribute chain
    #
    # @param value the value to set the attribute chain to.
    #
    # source://action_policy//lib/action_policy/lookup_chain.rb#53
    def chain=(_arg0); end

    # Returns the value of attribute namespace_cache_enabled.
    #
    # source://action_policy//lib/action_policy/lookup_chain.rb#53
    def namespace_cache_enabled; end

    # Sets the attribute namespace_cache_enabled
    #
    # @param value the value to set the attribute namespace_cache_enabled to.
    #
    # source://action_policy//lib/action_policy/lookup_chain.rb#53
    def namespace_cache_enabled=(_arg0); end

    # Returns the value of attribute namespace_cache_enabled.
    #
    # source://action_policy//lib/action_policy/lookup_chain.rb#53
    def namespace_cache_enabled?; end

    private

    # source://action_policy//lib/action_policy/lookup_chain.rb#67
    def lookup_within_namespace(policy_name, namespace, strict: T.unsafe(nil)); end

    # source://action_policy//lib/action_policy/lookup_chain.rb#87
    def policy_class_name_for(record); end
  end
end

# (Optional) Infer using String#classify if available
#
# source://action_policy//lib/action_policy/lookup_chain.rb#130
ActionPolicy::LookupChain::CLASSIFY_SYMBOL_LOOKUP = T.let(T.unsafe(nil), Proc)

# By record's class `policy_class` method
#
# source://action_policy//lib/action_policy/lookup_chain.rb#111
ActionPolicy::LookupChain::CLASS_POLICY_CLASS = T.let(T.unsafe(nil), Proc)

# Infer from class name
#
# source://action_policy//lib/action_policy/lookup_chain.rb#116
ActionPolicy::LookupChain::INFER_FROM_CLASS = T.let(T.unsafe(nil), Proc)

# By self `policy_class` method
#
# source://action_policy//lib/action_policy/lookup_chain.rb#106
ActionPolicy::LookupChain::INSTANCE_POLICY_CLASS = T.let(T.unsafe(nil), Proc)

# Cache namespace resolving result for policies.
#
# @see benchmarks/namespaced_lookup_cache.rb
#
# source://action_policy//lib/action_policy/lookup_chain.rb#23
class ActionPolicy::LookupChain::NamespaceCache
  class << self
    # source://action_policy//lib/action_policy/lookup_chain.rb#43
    def clear; end

    # source://action_policy//lib/action_policy/lookup_chain.rb#33
    def fetch(namespace, policy, strict:, &block); end

    # source://action_policy//lib/action_policy/lookup_chain.rb#27
    def put_if_absent(scope, namespace, policy); end

    # Returns the value of attribute store.
    #
    # source://action_policy//lib/action_policy/lookup_chain.rb#25
    def store; end
  end
end

# Infer from passed symbol
#
# source://action_policy//lib/action_policy/lookup_chain.rb#122
ActionPolicy::LookupChain::SYMBOL_LOOKUP = T.let(T.unsafe(nil), Proc)

# source://action_policy//lib/action_policy/policy/core.rb#31
class ActionPolicy::NonPredicateRule < ::ActionPolicy::UnknownRule
  # @return [NonPredicateRule] a new instance of NonPredicateRule
  #
  # source://action_policy//lib/action_policy/policy/core.rb#32
  def initialize(policy, rule); end
end

# Raised when Action Policy fails to find a policy class for a record.
#
# source://action_policy//lib/action_policy.rb#16
class ActionPolicy::NotFound < ::ActionPolicy::Error
  # @return [NotFound] a new instance of NotFound
  #
  # source://action_policy//lib/action_policy.rb#19
  def initialize(target, message = T.unsafe(nil)); end

  # Returns the value of attribute message.
  #
  # source://action_policy//lib/action_policy.rb#17
  def message; end

  # Returns the value of attribute target.
  #
  # source://action_policy//lib/action_policy.rb#17
  def target; end
end

# source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#4
module ActionPolicy::PerThreadCache
  class << self
    # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#22
    def clear_all; end

    # Sets the attribute enabled
    #
    # @param value the value to set the attribute enabled to.
    #
    # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#8
    def enabled=(_arg0); end

    # @return [Boolean]
    #
    # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#10
    def enabled?; end

    # source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#12
    def fetch(key); end
  end
end

# source://action_policy//lib/action_policy/behaviours/thread_memoized.rb#5
ActionPolicy::PerThreadCache::CACHE_KEY = T.let(T.unsafe(nil), String)

# source://action_policy//lib/action_policy/policy/execution_result.rb#4
module ActionPolicy::Policy; end

# Adds rules aliases support and ability to specify
# the default rule.
#
#   class ApplicationPolicy
#     include ActionPolicy::Policy::Core
#     include ActionPolicy::Policy::Aliases
#
#     # define which rule to use if `authorize!` called with
#     # unknown rule
#     default_rule :manage?
#
#     alias_rule :publish?, :unpublish?, to: :update?
#   end
#
# Aliases are used only during `authorize!` call (and do not act like _real_ aliases).
#
# Aliases useful when combined with `CachedApply` (since we can cache only the target rule).
#
# source://action_policy//lib/action_policy/policy/aliases.rb#22
module ActionPolicy::Policy::Aliases
  mixes_in_class_methods ::ActionPolicy::Policy::Aliases::ClassMethods

  # source://action_policy//lib/action_policy/policy/aliases.rb#31
  def resolve_rule(activity); end

  private

  # source://action_policy//lib/action_policy/policy/aliases.rb#39
  def check_rule_naming(activity); end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/aliases.rb#26
    def included(base); end
  end
end

# source://action_policy//lib/action_policy/policy/aliases.rb#46
module ActionPolicy::Policy::Aliases::ClassMethods
  # source://action_policy//lib/action_policy/policy/aliases.rb#51
  def alias_rule(*rules, to:); end

  # source://action_policy//lib/action_policy/policy/aliases.rb#47
  def default_rule(val); end

  # source://action_policy//lib/action_policy/policy/aliases.rb#57
  def lookup_alias(rule); end

  # source://action_policy//lib/action_policy/policy/aliases.rb#59
  def lookup_default_rule; end

  # source://action_policy//lib/action_policy/policy/aliases.rb#71
  def method_added(name); end

  # source://action_policy//lib/action_policy/policy/aliases.rb#61
  def rules_aliases; end
end

# source://action_policy//lib/action_policy/policy/aliases.rb#23
ActionPolicy::Policy::Aliases::DEFAULT = T.let(T.unsafe(nil), Symbol)

# Authorization context could include multiple parameters.
#
# It is possible to provide more verificatio contexts, by specifying them in the policy and
# providing them at the authorization step.
#
# For example:
#
#   class ApplicationPolicy < ActionPolicy::Base
#     # Add user and account to the context; it's required to be passed
#     # to a policy constructor and be not nil
#     authorize :user, :account
#
#     # you can skip non-nil check if you want
#     # authorize :account, allow_nil: true
#
#     def manage?
#       # available as a simple accessor
#       account.enabled?
#     end
#   end
#
#   ApplicantPolicy.new(user: user, account: account)
#
# source://action_policy//lib/action_policy/policy/authorization.rb#37
module ActionPolicy::Policy::Authorization
  mixes_in_class_methods ::ActionPolicy::Policy::Authorization::ClassMethods

  # source://action_policy//lib/action_policy/policy/authorization.rb#46
  def initialize(record = T.unsafe(nil), **params); end

  # Returns the value of attribute authorization_context.
  #
  # source://action_policy//lib/action_policy/policy/authorization.rb#44
  def authorization_context; end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/authorization.rb#39
    def included(base); end
  end
end

# source://action_policy//lib/action_policy/policy/authorization.rb#64
module ActionPolicy::Policy::Authorization::ClassMethods
  # source://action_policy//lib/action_policy/policy/authorization.rb#75
  def authorization_targets; end

  # source://action_policy//lib/action_policy/policy/authorization.rb#65
  def authorize(*ids, allow_nil: T.unsafe(nil), optional: T.unsafe(nil)); end
end

# Provides long-lived cache through ActionPolicy.cache_store.
#
# NOTE: if cache_store is nil then we silently skip all the caching.
#
# source://action_policy//lib/action_policy/policy/cache.rb#19
module ActionPolicy::Policy::Cache
  mixes_in_class_methods ::ActionPolicy::Policy::Cache::ClassMethods

  # source://action_policy//lib/action_policy/policy/cache.rb#64
  def apply(rule); end

  # source://action_policy//lib/action_policy/policy/cache.rb#48
  def apply_with_cache(rule); end

  # source://action_policy//lib/action_policy/policy/cache.rb#71
  def cache(*parts, **options); end

  # source://action_policy//lib/action_policy/policy/cache.rb#28
  def cache_key(*parts); end

  # source://action_policy//lib/action_policy/policy/cache.rb#26
  def cache_namespace; end

  # source://action_policy//lib/action_policy/policy/cache.rb#44
  def context_cache_key; end

  # source://action_policy//lib/action_policy/policy/cache.rb#35
  def rule_cache_key(rule); end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/cache.rb#21
    def included(base); end
  end
end

# source://action_policy//lib/action_policy/policy/cache.rb#82
module ActionPolicy::Policy::Cache::ClassMethods
  # source://action_policy//lib/action_policy/policy/cache.rb#83
  def cache(*rules, **options); end

  # source://action_policy//lib/action_policy/policy/cache.rb#89
  def cached_rules; end
end

# Per-policy cache for applied rules.
#
# When you call `apply` twice on the same policy and for the same rule,
# the check (and pre-checks) is only called once.
#
# source://action_policy//lib/action_policy/policy/cached_apply.rb#9
module ActionPolicy::Policy::CachedApply
  # source://action_policy//lib/action_policy/policy/cached_apply.rb#10
  def apply(rule); end
end

# Core policy API
#
# source://action_policy//lib/action_policy/policy/core.rb#41
module ActionPolicy::Policy::Core
  include ::ActionPolicy::Behaviours::PolicyFor

  mixes_in_class_methods ::ActionPolicy::Policy::Core::ClassMethods

  # NEXT_RELEASE: deprecate `record` arg, migrate to `record: nil`
  #
  # source://action_policy//lib/action_policy/policy/core.rb#78
  def initialize(record = T.unsafe(nil), *_arg1); end

  # This method performs the rule call.
  # Override or extend it to provide custom functionality
  # (such as caching, pre checks, etc.)
  #
  # source://action_policy//lib/action_policy/policy/core.rb#108
  def __apply__(rule); end

  # source://action_policy//lib/action_policy/policy/core.rb#100
  def allow!; end

  # Returns a result of applying the specified rule to the specified record.
  # Under the hood a policy class for record is resolved
  # (unless it's explicitly set through `with` option).
  #
  # If record is `nil` then we uses the current policy.
  #
  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/core.rb#125
  def allowed_to?(rule, record = T.unsafe(nil), **options); end

  # Returns a result of applying the specified rule (true of false).
  # Unlike simply calling a predicate rule (`policy.manage?`),
  # `apply` also calls pre-checks.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#85
  def apply(rule); end

  # An alias for readability purposes
  #
  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/core.rb#136
  def check?(*args, **hargs); end

  # source://action_policy//lib/action_policy/policy/core.rb#95
  def deny!; end

  # Return annotated source code for the rule
  # NOTE: require "method_source" and "unparser" gems to be installed.
  # Otherwise returns empty string.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#152
  def inspect_rule(rule); end

  # Helper for printing the annotated rule source.
  # Useful for debugging: type `pp :show?` within the context of the policy
  # to preview the rule.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#157
  def pp(rule); end

  # Returns the value of attribute record.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#75
  def record; end

  # Returns a rule name (policy method name) for activity.
  #
  # By default, rule name is equal to activity name.
  #
  # Raises ActionPolicy::UnknownRule when rule is not found in policy.
  #
  # @raise [UnknownRule]
  #
  # source://action_policy//lib/action_policy/policy/core.rb#143
  def resolve_rule(activity); end

  # Returns the value of attribute result.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#75
  def result; end

  # Wrap code that could modify result
  # to prevent the current result modification
  #
  # source://action_policy//lib/action_policy/policy/core.rb#112
  def with_clean_result; end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/core.rb#43
    def included(base); end
  end
end

# source://action_policy//lib/action_policy/policy/core.rb#58
module ActionPolicy::Policy::Core::ClassMethods
  # source://action_policy//lib/action_policy/policy/core.rb#66
  def identifier; end

  # Sets the attribute identifier
  #
  # @param value the value to set the attribute identifier to.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#59
  def identifier=(_arg0); end

  # source://action_policy//lib/action_policy/policy/core.rb#61
  def result_class; end
end

# Create default rules and aliases:
# - `index?` (=`false`)
# - `create?` (=`false`)
# - `new?` as an alias for `create?`
# - `manage?` as a fallback for all unspecified rules (default rule)
#
# source://action_policy//lib/action_policy/policy/defaults.rb#10
module ActionPolicy::Policy::Defaults
  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/defaults.rb#26
  def create?; end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/defaults.rb#24
  def index?; end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/defaults.rb#28
  def manage?; end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/defaults.rb#11
    def included(base); end
  end
end

# Result of applying a policy rule
#
# This class could be extended by some modules to provide
# additional functionality
#
# source://action_policy//lib/action_policy/policy/execution_result.rb#9
class ActionPolicy::Policy::ExecutionResult
  # @return [ExecutionResult] a new instance of ExecutionResult
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#12
  def initialize(policy, rule); end

  # source://action_policy//lib/action_policy/policy/execution_result.rb#26
  def cached!; end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#30
  def cached?; end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#24
  def fail?; end

  # source://action_policy//lib/action_policy/policy/execution_result.rb#32
  def inspect; end

  # Populate the final value
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#18
  def load(value); end

  # Returns the value of attribute policy.
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#10
  def policy; end

  # Returns the value of attribute rule.
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#10
  def rule; end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#22
  def success?; end

  # Returns the value of attribute value.
  #
  # source://action_policy//lib/action_policy/policy/execution_result.rb#10
  def value; end
end

# Failures reasons store
#
# source://action_policy//lib/action_policy/policy/reasons.rb#8
class ActionPolicy::Policy::FailureReasons
  # @return [FailureReasons] a new instance of FailureReasons
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#11
  def initialize; end

  # source://action_policy//lib/action_policy/policy/reasons.rb#15
  def add(policy_or_class, rule, details = T.unsafe(nil)); end

  # Return Hash of the form:
  #   { policy_identifier => [rules, ...] }
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#28
  def details; end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#30
  def empty?; end

  # source://action_policy//lib/action_policy/policy/reasons.rb#34
  def merge(other); end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#32
  def present?; end

  # Returns the value of attribute reasons.
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#9
  def reasons; end

  private

  # source://action_policy//lib/action_policy/policy/reasons.rb#61
  def add_detailed_reason(store, detailed_rule); end

  # source://action_policy//lib/action_policy/policy/reasons.rb#50
  def add_non_detailed_reason(store, rule); end

  # source://action_policy//lib/action_policy/policy/reasons.rb#66
  def with_details(rule, details); end
end

# Adds callback-style checks to policies to
# extract common checks from rules.
#
#    class ApplicationPolicy < ActionPolicy::Base
#      authorize :user
#      pre_check :allow_admins
#
#      private
#        # Allow every action for admins
#        def allow_admins
#          allow! if user.admin?
#        end
#    end
#
# You can specify conditional pre-checks (through `except` / `only`) options
# and skip already defined pre-checks if necessary.
#
#    class UserPolicy < ApplicationPolicy
#      skip_pre_check :allow_admins, only: :destroy?
#
#      def destroy?
#        user.admin? && !record.admin?
#      end
#    end
#
# source://action_policy//lib/action_policy/policy/pre_check.rb#29
module ActionPolicy::Policy::PreCheck
  mixes_in_class_methods ::ActionPolicy::Policy::PreCheck::ClassMethods

  # source://action_policy//lib/action_policy/policy/pre_check.rb#122
  def __apply__(rule); end

  # source://action_policy//lib/action_policy/policy/pre_check.rb#113
  def run_pre_checks(rule); end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/pre_check.rb#108
    def included(base); end
  end
end

# Single pre-check instance.
#
# Implements filtering logic.
#
# source://action_policy//lib/action_policy/policy/pre_check.rb#33
class ActionPolicy::Policy::PreCheck::Check
  # @return [Check] a new instance of Check
  #
  # source://action_policy//lib/action_policy/policy/pre_check.rb#36
  def initialize(policy, name, except: T.unsafe(nil), only: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/pre_check.rb#50
  def applicable?(rule); end

  # source://action_policy//lib/action_policy/policy/pre_check.rb#55
  def call(policy); end

  # source://action_policy//lib/action_policy/policy/pre_check.rb#84
  def dup; end

  # Returns the value of attribute name.
  #
  # source://action_policy//lib/action_policy/policy/pre_check.rb#34
  def name; end

  # Returns the value of attribute policy_class.
  #
  # source://action_policy//lib/action_policy/policy/pre_check.rb#34
  def policy_class; end

  # source://action_policy//lib/action_policy/policy/pre_check.rb#57
  def skip!(except: T.unsafe(nil), only: T.unsafe(nil)); end

  private

  # Returns the value of attribute blacklist.
  #
  # source://action_policy//lib/action_policy/policy/pre_check.rb#95
  def blacklist; end

  # Returns the value of attribute filter.
  #
  # source://action_policy//lib/action_policy/policy/pre_check.rb#95
  def filter; end

  # source://action_policy//lib/action_policy/policy/pre_check.rb#97
  def rebuild_filter; end

  # Returns the value of attribute whitelist.
  #
  # source://action_policy//lib/action_policy/policy/pre_check.rb#95
  def whitelist; end
end

# source://action_policy//lib/action_policy/policy/pre_check.rb#126
module ActionPolicy::Policy::PreCheck::ClassMethods
  # source://action_policy//lib/action_policy/policy/pre_check.rb#127
  def pre_check(*names, **options); end

  # source://action_policy//lib/action_policy/policy/pre_check.rb#150
  def pre_checks; end

  # source://action_policy//lib/action_policy/policy/pre_check.rb#137
  def skip_pre_check(*names, **options); end
end

# Provides failure reasons tracking functionality.
# That allows you to distinguish between the reasons why authorization was rejected.
#
# It's helpful when you compose policies (i.e. use one policy within another).
#
# For example:
#
#   class ApplicantPolicy < ApplicationPolicy
#     def show?
#       user.has_permission?(:view_applicants) &&
#         allowed_to?(:show?, object.stage)
#     end
#   end
#
# Now when you receive an exception, you have a reasons object, which contains additional
# information about the failure:
#
#   rescue_from ActionPolicy::Unauthorized do |ex|
#     ex.policy #=> ApplicantPolicy
#     ex.rule #=> :show?
#     ex.result.reasons.details  #=> {stage: [:show?]}
#   end
#
# NOTE: the reason key (`stage`) is a policy identifier (underscored class name by default).
# For namespaced policies it has a form of:
#
#   class Admin::UserPolicy < ApplicationPolicy
#     # ..
#   end
#
#   reasons.details #=> {:"admin/user" => [:show?]}
#
#
# You can also wrap _local_ rules into `allowed_to?` to populate reasons:
#
#   class ApplicantPolicy < ApplicationPolicy
#     def show?
#       allowed_to?(:view_applicants?) &&
#         allowed_to?(:show?, object.stage)
#     end
#
#     def view_applicants?
#       user.has_permission?(:view_applicants)
#     end
#   end
#
# NOTE: there is `check?` alias for `allowed_to?`.
#
# You can provide additional details to your failure reasons by using
# a `details: { ... }` option:
#
#   class ApplicantPolicy < ApplicationPolicy
#     def show?
#       allowed_to?(:show?, object.stage)
#     end
#   end
#
#   class StagePolicy < ApplicationPolicy
#     def show?
#       # Add stage title to the failure reason (if any)
#       # (could be used by client to show more descriptive message)
#       details[:title] = record.title
#
#       # then perform the checks
#       user.stages.where(id: record.id).exists?
#     end
#   end
#
#   # when accessing the reasons
#   p ex.result.reasons.details #=> { stage: [{show?: {title: "Onboarding"}] }
#
# NOTE: when using detailed reasons, the `details` array contains as the last element
# a hash with ALL details reasons for the policy (in a form of <rule> => <details>).
#
# source://action_policy//lib/action_policy/policy/reasons.rb#187
module ActionPolicy::Policy::Reasons
  # @return [Boolean]
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#199
  def allowed_to?(rule, record = T.unsafe(nil), inline_reasons: T.unsafe(nil), **options); end

  # source://action_policy//lib/action_policy/policy/reasons.rb#222
  def deny!(reason = T.unsafe(nil)); end

  # Add additional details to the failure reason
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#195
  def details; end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/reasons.rb#189
    def included(base); end
  end
end

# Extend ExecutionResult with `reasons` method
#
# source://action_policy//lib/action_policy/policy/reasons.rb#74
module ActionPolicy::Policy::ResultFailureReasons
  # Returns all the details merged together
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#86
  def all_details; end

  # source://action_policy//lib/action_policy/policy/reasons.rb#81
  def clear_details; end

  # Returns the value of attribute details.
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#79
  def details; end

  # Sets the attribute details
  #
  # @param value the value to set the attribute details to.
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#79
  def details=(_arg0); end

  # Add reasons to inspect
  #
  # source://action_policy//lib/action_policy/policy/reasons.rb#105
  def inspect; end

  # source://action_policy//lib/action_policy/policy/reasons.rb#75
  def reasons; end
end

# Scoping is used to modify the _object under authorization_.
#
# The most common situation is when you want to _scope_ the collection depending
# on the current user permissions.
#
# For example:
#
#   class ApplicationPolicy < ActionPolicy::Base
#     # Scoping only makes sense when you have the authorization context
#     authorize :user
#
#     # :relation here is a scoping type
#     scope_for :relation do |relation|
#       # authorization context is available within a scope
#       if user.admin?
#         relation
#       else
#         relation.publicly_visible
#       end
#     end
#   end
#
#   base_scope = User.all
#   authorized_scope = ApplicantPolicy.new(user: user)
#    .apply_scope(base_scope, type: :relation)
#
# source://action_policy//lib/action_policy/policy/scoping.rb#79
module ActionPolicy::Policy::Scoping
  include ::ActionPolicy::Behaviours::Scoping

  mixes_in_class_methods ::ActionPolicy::Policy::Scoping::ClassMethods

  # Pass target to the scope handler of the specified type and name.
  # If `name` is not specified then `:default` name is used.
  # If `type` is not specified then we try to infer the type from the
  # target class.
  #
  # @raise [ActionPolicy::UnknownScopeType]
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#92
  def apply_scope(target, type:, name: T.unsafe(nil), scope_options: T.unsafe(nil)); end

  # source://action_policy//lib/action_policy/policy/scoping.rb#108
  def lookup_type_from_target(target); end

  # source://action_policy//lib/action_policy/policy/scoping.rb#103
  def resolve_scope_type(target); end

  class << self
    # @private
    #
    # source://action_policy//lib/action_policy/policy/scoping.rb#81
    def included(base); end
  end
end

# source://action_policy//lib/action_policy/policy/scoping.rb#114
module ActionPolicy::Policy::Scoping::ClassMethods
  # Register a new scoping method for the `type`
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#116
  def scope_for(type, name = T.unsafe(nil), &block); end

  # Define scope type matcher.
  #
  # Scope matcher is an object that implements `#===` (_case equality_) or a Proc.
  #
  # When no type is provided when applying a scope we try to infer a type
  # from the target object by calling matchers one by one until we find a matching
  # type (i.e. there is a matcher which returns `true` when applying it to the target).
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#144
  def scope_matcher(type, class_or_proc); end

  # source://action_policy//lib/action_policy/policy/scoping.rb#148
  def scope_matchers; end

  # source://action_policy//lib/action_policy/policy/scoping.rb#124
  def scoping_handlers; end
end

module ActionPolicy::PrettyPrint
  class << self
    def available?; end
    def colorize(val); end
    def ignore_expressions; end
    def ignore_expressions=(_arg0); end
    def print_method(object, method_name); end
  end
end

ActionPolicy::PrettyPrint::FALSE = T.let(T.unsafe(nil), String)
ActionPolicy::PrettyPrint::TRUE = T.let(T.unsafe(nil), String)

class ActionPolicy::PrettyPrint::Visitor
  def initialize(object); end

  def collect(ast); end
  def eval_exp(exp); end
  def expression_with_result(sexp); end
  def ignore_exp?(exp); end
  def indent; end
  def indent=(_arg0); end
  def indented(str); end
  def lines; end
  def object; end
  def visit_and(ast); end
  def visit_begin(ast); end
  def visit_missing(ast); end
  def visit_node(ast); end
  def visit_or(ast); end
end

# source://action_policy//lib/action_policy/railtie.rb#9
class ActionPolicy::Railtie < ::Rails::Railtie; end

# Provides Rails-specific configuration,
# accessible through `Rails.application.config.action_policy`
#
# source://action_policy//lib/action_policy/railtie.rb#10
module ActionPolicy::Railtie::Config
  class << self
    # Define whether we need to include ActionCable::Channel::Base
    # with the default authorization logic
    #
    # source://action_policy//lib/action_policy/railtie.rb#22
    def auto_inject_into_channel; end

    # Define whether we need to include ActionCable::Channel::Base
    # with the default authorization logic
    #
    # source://action_policy//lib/action_policy/railtie.rb#22
    def auto_inject_into_channel=(_arg0); end

    # Define whether we need to extend ApplicationController::Base
    # with the default authorization logic
    #
    # source://action_policy//lib/action_policy/railtie.rb#14
    def auto_inject_into_controller; end

    # Define whether we need to extend ApplicationController::Base
    # with the default authorization logic
    #
    # source://action_policy//lib/action_policy/railtie.rb#14
    def auto_inject_into_controller=(_arg0); end

    # source://action_policy//lib/action_policy/railtie.rb#37
    def cache_store=(store); end

    # Define whether we want to specify `current_user` as
    # the default authorization context in channels
    #
    # source://action_policy//lib/action_policy/railtie.rb#26
    def channel_authorize_current_user; end

    # Define whether we want to specify `current_user` as
    # the default authorization context in channels
    #
    # source://action_policy//lib/action_policy/railtie.rb#26
    def channel_authorize_current_user=(_arg0); end

    # Define whether we want to specify `current_user` as
    # the default authorization context in controller
    #
    # source://action_policy//lib/action_policy/railtie.rb#18
    def controller_authorize_current_user; end

    # Define whether we want to specify `current_user` as
    # the default authorization context in controller
    #
    # source://action_policy//lib/action_policy/railtie.rb#18
    def controller_authorize_current_user=(_arg0); end

    # Define whether to include instrumentation functionality.
    # Enabled by default.
    #
    # source://action_policy//lib/action_policy/railtie.rb#35
    def instrumentation_enabled; end

    # Define whether to include instrumentation functionality.
    # Enabled by default.
    #
    # source://action_policy//lib/action_policy/railtie.rb#35
    def instrumentation_enabled=(_arg0); end

    # Define whether to cache namespaced policy resolution
    # result (e.g. in controllers).
    # Enabled only in production by default.
    #
    # source://action_policy//lib/action_policy/railtie.rb#31
    def namespace_cache_enabled; end

    # Define whether to cache namespaced policy resolution
    # result (e.g. in controllers).
    # Enabled only in production by default.
    #
    # source://action_policy//lib/action_policy/railtie.rb#31
    def namespace_cache_enabled=(_arg0); end
  end
end

# Adds `suggest` method which uses did_you_mean
# to generate a suggestion message
#
# source://action_policy//lib/action_policy/utils/suggest_message.rb#6
module ActionPolicy::SuggestMessage
  # source://action_policy//lib/action_policy/utils/suggest_message.rb#8
  def suggest(needle, heystack); end
end

# Raised when `authorize!` check fails
#
# source://action_policy//lib/action_policy/authorizer.rb#5
class ActionPolicy::Unauthorized < ::ActionPolicy::Error
  # @return [Unauthorized] a new instance of Unauthorized
  #
  # source://action_policy//lib/action_policy/authorizer.rb#8
  def initialize(policy, rule); end

  # Returns the value of attribute policy.
  #
  # source://action_policy//lib/action_policy/authorizer.rb#6
  def policy; end

  # Returns the value of attribute result.
  #
  # source://action_policy//lib/action_policy/authorizer.rb#6
  def result; end

  # Returns the value of attribute rule.
  #
  # source://action_policy//lib/action_policy/authorizer.rb#6
  def rule; end
end

# Raised when `authorize!` hasn't been called for action
#
# source://action_policy//lib/action_policy/rails/controller.rb#8
class ActionPolicy::UnauthorizedAction < ::ActionPolicy::Error
  # @return [UnauthorizedAction] a new instance of UnauthorizedAction
  #
  # source://action_policy//lib/action_policy/rails/controller.rb#9
  def initialize(controller, action); end
end

# source://action_policy//lib/action_policy/policy/scoping.rb#24
class ActionPolicy::UnknownNamedScope < ::ActionPolicy::Error
  include ::ActionPolicy::SuggestMessage

  # @return [UnknownNamedScope] a new instance of UnknownNamedScope
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#31
  def initialize(policy_class, type, name); end

  # Returns the value of attribute message.
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#29
  def message; end
end

# source://action_policy//lib/action_policy/policy/scoping.rb#27
ActionPolicy::UnknownNamedScope::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# Raised when `resolve_rule` failed to find an approriate
# policy rule method for the activity
#
# source://action_policy//lib/action_policy/policy/core.rb#18
class ActionPolicy::UnknownRule < ::ActionPolicy::Error
  include ::ActionPolicy::SuggestMessage

  # @return [UnknownRule] a new instance of UnknownRule
  #
  # source://action_policy//lib/action_policy/policy/core.rb#23
  def initialize(policy, rule); end

  # Returns the value of attribute message.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#21
  def message; end

  # Returns the value of attribute policy.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#21
  def policy; end

  # Returns the value of attribute rule.
  #
  # source://action_policy//lib/action_policy/policy/core.rb#21
  def rule; end
end

# source://action_policy//lib/action_policy/policy/scoping.rb#8
class ActionPolicy::UnknownScopeType < ::ActionPolicy::Error
  include ::ActionPolicy::SuggestMessage

  # @return [UnknownScopeType] a new instance of UnknownScopeType
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#15
  def initialize(policy_class, type); end

  # Returns the value of attribute message.
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#13
  def message; end
end

# source://action_policy//lib/action_policy/policy/scoping.rb#11
ActionPolicy::UnknownScopeType::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# source://action_policy//lib/action_policy/policy/scoping.rb#39
class ActionPolicy::UnrecognizedScopeTarget < ::ActionPolicy::Error
  # @return [UnrecognizedScopeTarget] a new instance of UnrecognizedScopeTarget
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#44
  def initialize(target); end

  # Returns the value of attribute message.
  #
  # source://action_policy//lib/action_policy/policy/scoping.rb#42
  def message; end
end

# source://action_policy//lib/action_policy/policy/scoping.rb#40
ActionPolicy::UnrecognizedScopeTarget::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# source://action_policy//lib/action_policy/version.rb#4
ActionPolicy::VERSION = T.let(T.unsafe(nil), String)
